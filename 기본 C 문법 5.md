# C Programming Session 6: 포인터와 배열

## 학습 목표
- 배열 이름과 포인터의 관계 이해
- 포인터 산술 연산 학습
- `arr[i]`와 `*(arr + i)`의 동치성 이해
- 포인터로 배열 순회하기
- 문자열과 포인터의 관계
- 함수에 배열을 전달하는 원리 이해
- 문자열 함수 직접 구현하기

---

## 1. 동기부여: 배열은 왜 다르게 동작할까? (15분)

### 지난 시간의 미스터리

**세션 5 실습 2를 기억하시나요?**

```c
#include <stdio.h>

void modify(int n) {
    n = n * 2;
    printf("함수 안: n = %d\n", n);
}

void modifyArray(int arr[3]) {
    arr[0] = 100;
    printf("함수 안: arr[0] = %d\n", arr[0]);
}

int main(void) {
    int x = 5;
    printf("호출 전: x = %d\n", x);
    modify(x);
    printf("호출 후: x = %d\n", x);  // 5 (안 바뀜)
    
    printf("\n");
    
    int numbers[3] = {1, 2, 3};
    printf("호출 전: numbers[0] = %d\n", numbers[0]);
    modifyArray(numbers);
    printf("호출 후: numbers[0] = %d\n", numbers[0]);  // 100 (바뀜!)
    
    return 0;
}
```

**출력:**
```
호출 전: x = 5
함수 안: n = 10
호출 후: x = 5          ← 안 바뀜

호출 전: numbers[0] = 1
함수 안: arr[0] = 100
호출 후: numbers[0] = 100  ← 바뀜!!!
```

### 핵심 질문

1. **왜 `x`는 안 바뀌는데 `numbers`는 바뀔까?**
2. **배열은 call by reference인가?**
3. **배열을 함수에 전달하면 정확히 무슨 일이 일어나나?**

**오늘의 목표**: 이 미스터리를 완전히 이해하자!

**힌트**: 배열 이름 `numbers`는 사실...

---

## 2. 배열 이름과 포인터의 관계 (25분)

### 2.1 배열 이름의 정체

**중요한 사실**: 대부분의 경우, **배열 이름은 첫 번째 원소의 주소**입니다.

```c
int arr[5] = {10, 20, 30, 40, 50};

// 다음 세 가지는 모두 같은 값!
arr           // 배열 이름
&arr[0]       // 첫 번째 원소의 주소
```

**확인해보기:**
```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    printf("arr = %p\n", arr);
    printf("&arr[0] = %p\n", &arr[0]);
    printf("&arr[1] = %p\n", &arr[1]);
    
    printf("\narr[0] = %d\n", arr[0]);
    printf("*arr = %d\n", *arr);  // arr을 포인터처럼 사용!
    
    return 0;
}
```

**출력 예시:**
```
arr = 0x7ffc1234ab00
&arr[0] = 0x7ffc1234ab00    ← 같은 주소!
&arr[1] = 0x7ffc1234ab04    ← 4바이트 뒤 (int 크기)

arr[0] = 10
*arr = 10                    ← 같은 값!
```

**메모리 시각화:**
```
주소          값
0x1000:      [10]  ← arr[0], *arr
0x1004:      [20]  ← arr[1]
0x1008:      [30]  ← arr[2]
0x100C:      [40]  ← arr[3]
0x1010:      [50]  ← arr[4]

arr → 0x1000 (첫 번째 원소의 주소)
```

**수학적 표현:**
```
arr ≡ &arr[0]

*arr ≡ arr[0]
```

**출처**: [ISO C Standard](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.3.2.1

### 2.2 배열 이름 vs 포인터 변수

**중요한 차이**: 배열 이름은 포인터처럼 보이지만, **상수 포인터**입니다.

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;  // OK: 포인터에 배열 주소 할당

// 포인터 변수는 변경 가능
ptr = ptr + 1;   // OK
ptr++;           // OK

// 배열 이름은 변경 불가능
arr = arr + 1;   // 컴파일 오류!
arr++;           // 컴파일 오류!
```

**비유:**
```
배열 이름 (arr)  = 집 주소 (고정됨, 바꿀 수 없음)
포인터 변수 (ptr) = GPS 위치 (변경 가능, 어디든 갈 수 있음)
```

**표로 정리:**

| 특성 | 배열 이름 `arr` | 포인터 변수 `int *ptr` |
|------|----------------|----------------------|
| 값 | 첫 번째 원소 주소 | 주소 값 |
| 변경 가능? | 불가능 (상수) | 가능 |
| `*arr` 가능? | 가능 | 가능 |
| `arr++` 가능? | 불가능 | 가능 |
| `sizeof(arr)` | 전체 배열 크기 | 포인터 크기 (8바이트) |

**sizeof 차이 확인:**
```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;
    
    printf("sizeof(arr) = %zu\n", sizeof(arr));   // 20 (5 * 4)
    printf("sizeof(ptr) = %zu\n", sizeof(ptr));   // 8 (64비트 시스템)
    
    return 0;
}
```

### 2.3 실습 1: 배열과 포인터 기초 (10분)

**문제**: 다음 코드의 출력을 예측하고 실행해보세요

```c
#include <stdio.h>

int main(void) {
    int numbers[4] = {100, 200, 300, 400};
    int *p = numbers;
    
    printf("numbers = %p\n", numbers);
    printf("p = %p\n", p);
    printf("&numbers[0] = %p\n", &numbers[0]);
    
    printf("\n");
    
    printf("numbers[0] = %d\n", numbers[0]);
    printf("*numbers = %d\n", *numbers);
    printf("*p = %d\n", *p);
    
    printf("\n");
    
    printf("numbers[1] = %d\n", numbers[1]);
    printf("*(numbers + 1) = %d\n", *(numbers + 1));
    printf("*(p + 1) = %d\n", *(p + 1));
    
    return 0;
}
```

**확인할 점:**
- 세 주소가 모두 같은가?
- `*numbers`와 `numbers[0]`이 같은가?
- `*(numbers + 1)`과 `numbers[1]`이 같은가?

---

## 3. 포인터 산술 연산 (30분)

### 3.1 포인터에 정수 더하기

**핵심**: 포인터에 1을 더하면 **다음 원소**를 가리킵니다.

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;  // ptr은 arr[0]을 가리킴

ptr + 0  // arr[0]의 주소
ptr + 1  // arr[1]의 주소
ptr + 2  // arr[2]의 주소
```

**주의**: 바이트 단위가 아니라 **원소 단위**로 이동합니다!

```c
int arr[3];      // int는 4바이트
int *ptr = arr;

ptr + 1  // 주소가 4바이트 증가 (1개 원소 크기)
ptr + 2  // 주소가 8바이트 증가 (2개 원소 크기)

double darr[3];  // double은 8바이트
double *dptr = darr;

dptr + 1 // 주소가 8바이트 증가
```

**메모리 시각화:**
```
int arr[5] = {10, 20, 30, 40, 50};

주소          값         포인터 표현
0x1000:      [10]  ←  arr, arr+0, &arr[0]
0x1004:      [20]  ←  arr+1, &arr[1]
0x1008:      [30]  ←  arr+2, &arr[2]
0x100C:      [40]  ←  arr+3, &arr[3]
0x1010:      [50]  ←  arr+4, &arr[4]

arr + 1의 값 = 0x1004 (0x1000 + 4)
```

**출처**: [ISO C Standard - Pointer Arithmetic](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.6

### 3.2 arr[i]와 *(arr + i)의 관계

**놀라운 사실**: 다음 두 표현은 **완전히 동일**합니다!

```c
arr[i]  ≡  *(arr + i)
```

**증명:**
```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d, *(arr + %d) = %d\n", 
               i, arr[i], i, *(arr + i));
    }
    
    return 0;
}
```

**출력:**
```
arr[0] = 10, *(arr + 0) = 10
arr[1] = 20, *(arr + 1) = 20
arr[2] = 30, *(arr + 2) = 30
arr[3] = 40, *(arr + 3) = 40
arr[4] = 50, *(arr + 4) = 50
```

**원리:**
```
arr[i]는 실제로 컴파일러가 *(arr + i)로 변환합니다!

arr[2]
→ *(arr + 2)
→ arr의 주소에서 2칸 이동한 곳의 값
→ &arr[0] + 2 * sizeof(int)
→ 해당 주소의 값
```

**재미있는 결과:**
```c
int arr[5] = {10, 20, 30, 40, 50};

arr[2]  ≡  *(arr + 2)  ≡  *(2 + arr)  ≡  2[arr]  // 모두 같음!

// 실제로 작동함 (하지만 사용하지 마세요!)
printf("%d\n", 2[arr]);  // 30 출력
```

### 3.3 포인터로 배열 순회하기

**방법 1: 인덱스 사용 (전통적)**
```c
int arr[5] = {10, 20, 30, 40, 50};

for (int i = 0; i < 5; i++) {
    printf("%d ", arr[i]);
}
```

**방법 2: 포인터 산술 사용**
```c
int arr[5] = {10, 20, 30, 40, 50};

for (int i = 0; i < 5; i++) {
    printf("%d ", *(arr + i));
}
```

**방법 3: 포인터 변수 증가**
```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;

for (int i = 0; i < 5; i++) {
    printf("%d ", *ptr);
    ptr++;  // 다음 원소로 이동
}
```

**방법 4: 포인터 범위 체크**
```c
int arr[5] = {10, 20, 30, 40, 50};
int *end = arr + 5;  // 배열 끝 다음 주소

for (int *ptr = arr; ptr < end; ptr++) {
    printf("%d ", *ptr);
}
```

### 3.4 포인터 뺄셈

**두 포인터의 차이**: 원소 개수를 반환

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];  // 20을 가리킴
int *p2 = &arr[4];  // 50을 가리킴

printf("%ld\n", p2 - p1);  // 3 (원소 3개 차이)
printf("%ld\n", p1 - p2);  // -3
```

**활용 예시 - 배열 크기 계산:**
```c
int arr[10];
int size = (&arr[10] - &arr[0]);  // 10
// 또는
int size = (arr + 10) - arr;      // 10
```

### 3.5 포인터 비교

**포인터끼리 비교 가능:**
```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;

while (ptr < arr + 5) {  // 배열 끝까지
    printf("%d ", *ptr);
    ptr++;
}
```

**주의**: 같은 배열 내의 포인터만 비교 가능!

### 3.6 실습 2: 포인터 산술 연습 (15분)

**문제 1**: 포인터로 배열 역순 출력

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // 여기에 코드 작성
    // 포인터를 사용하여 50, 40, 30, 20, 10 순서로 출력
    // 힌트: arr + 4부터 시작해서 감소
    
    return 0;
}
```

**목표 출력:**
```
50 40 30 20 10
```

---

**문제 2**: 두 포인터 사이의 합 구하기

```c
#include <stdio.h>

int main(void) {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int *start = &arr[2];  // 3을 가리킴
    int *end = &arr[7];    // 8을 가리킴
    
    // start부터 end까지 (포함)의 합 구하기
    // 포인터를 사용하여 계산
    
    int sum = 0;
    // 여기에 코드 작성
    
    printf("Sum = %d\n", sum);  // 3+4+5+6+7+8 = 33
    
    return 0;
}
```

---

## 4. 문자열과 포인터 (35분)

### 4.1 문자열의 두 가지 표현

**방법 1: 문자 배열**
```c
char str1[6] = "Hello";  // 배열

// 메모리 (스택):
// str1[0] = 'H'
// str1[1] = 'e'
// str1[2] = 'l'
// str1[3] = 'l'
// str1[4] = 'o'
// str1[5] = '\0'  (null terminator)
```

**방법 2: 문자 포인터**
```c
char *str2 = "Hello";    // 포인터

// "Hello"는 읽기 전용 메모리 (코드 영역)에 저장
// str2는 그 주소를 가리킴
```

**차이점:**

| 특성 | `char arr[]` | `char *ptr` |
|------|-------------|-------------|
| 저장 위치 | 스택 (배열) | 포인터는 스택, 문자열은 코드 영역 |
| 수정 가능? | 가능 | 불가능 (리터럴은 읽기 전용) |
| 크기 | 배열 크기 | 포인터 크기 (8바이트) |

**실험:**
```c
#include <stdio.h>

int main(void) {
    char str1[6] = "Hello";
    char *str2 = "Hello";
    
    printf("str1: %s\n", str1);
    printf("str2: %s\n", str2);
    
    str1[0] = 'h';  // OK: 배열은 수정 가능
    printf("str1: %s\n", str1);  // "hello"
    
    // str2[0] = 'h';  // 위험! 세그먼테이션 오류 가능
                       // 읽기 전용 메모리 수정 시도
    
    return 0;
}
```

**메모리 구조:**
```
[ 스택 ]
str1: ['H']['e']['l']['l']['o']['\0']  ← 수정 가능
str2: [주소 0x400500]
       ↓
[ 코드 영역 ]
0x400500: ['H']['e']['l']['l']['o']['\0']  ← 읽기 전용
```

**출처**: [ISO C Standard - String Literals](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.4.5

### 4.2 문자열 순회

**방법 1: 인덱스**
```c
char str[] = "Hello";
for (int i = 0; str[i] != '\0'; i++) {
    printf("%c ", str[i]);
}
```

**방법 2: 포인터**
```c
char str[] = "Hello";
char *ptr = str;

while (*ptr != '\0') {
    printf("%c ", *ptr);
    ptr++;
}
```

**방법 3: 포인터 (for문)**
```c
char str[] = "Hello";
for (char *ptr = str; *ptr != '\0'; ptr++) {
    printf("%c ", *ptr);
}
```

### 4.3 문자열 함수 직접 구현하기

#### strlen 구현

**표준 함수:**
```c
#include <string.h>
size_t strlen(const char *str);
```

**직접 구현:**
```c
#include <stdio.h>

int my_strlen(char *str) {
    int length = 0;
    while (*str != '\0') {
        length++;
        str++;  // 다음 문자로 이동
    }
    return length;
}

// 또는 포인터 산술 사용
int my_strlen_v2(char *str) {
    char *ptr = str;
    while (*ptr != '\0') {
        ptr++;
    }
    return ptr - str;  // 포인터 차이 = 길이
}

int main(void) {
    char str[] = "Hello";
    printf("Length: %d\n", my_strlen(str));     // 5
    printf("Length: %d\n", my_strlen_v2(str));  // 5
    return 0;
}
```

**출처**: [ISO C Standard - strlen](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 7.24.6.3

#### strcpy 구현

**표준 함수:**
```c
char *strcpy(char *dest, const char *src);
```

**직접 구현:**
```c
#include <stdio.h>

void my_strcpy(char *dest, char *src) {
    while (*src != '\0') {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';  // null terminator 복사
}

// 간결한 버전
void my_strcpy_v2(char *dest, char *src) {
    while ((*dest++ = *src++) != '\0') {
        // 대입과 비교를 한 번에
    }
}

int main(void) {
    char src[] = "Hello";
    char dest[20];
    
    my_strcpy(dest, src);
    printf("dest: %s\n", dest);  // "Hello"
    
    return 0;
}
```

**출처**: [ISO C Standard - strcpy](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 7.24.2.3

#### strcmp 구현

**표준 함수:**
```c
int strcmp(const char *s1, const char *s2);
// 반환값: s1 < s2 이면 음수, s1 == s2 이면 0, s1 > s2 이면 양수
```

**직접 구현:**
```c
#include <stdio.h>

int my_strcmp(char *s1, char *s2) {
    while (*s1 != '\0' && *s2 != '\0') {
        if (*s1 != *s2) {
            return *s1 - *s2;
        }
        s1++;
        s2++;
    }
    return *s1 - *s2;  // 길이가 다른 경우 처리
}

int main(void) {
    printf("%d\n", my_strcmp("abc", "abc"));  // 0
    printf("%d\n", my_strcmp("abc", "abd"));  // 음수
    printf("%d\n", my_strcmp("abd", "abc"));  // 양수
    printf("%d\n", my_strcmp("ab", "abc"));   // 음수 (짧음)
    
    return 0;
}
```

**출처**: [ISO C Standard - strcmp](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 7.24.4.2

### 4.4 실습 3: 문자열 함수 구현 (20분)

**문제 1**: 문자열 뒤집기

```c
#include <stdio.h>

void reverse_string(char *str) {
    // 여기에 코드 작성
    // 힌트:
    // 1. 문자열 길이 구하기
    // 2. 시작과 끝 포인터 사용
    // 3. swap하며 중간까지 이동
}

int main(void) {
    char str[] = "Hello";
    printf("Original: %s\n", str);
    
    reverse_string(str);
    printf("Reversed: %s\n", str);  // "olleH"
    
    return 0;
}
```

---

**문제 2**: 문자열에서 특정 문자 개수 세기

```c
#include <stdio.h>

int count_char(char *str, char c) {
    // 여기에 코드 작성
    // str에서 문자 c가 몇 번 나타나는지 세기
}

int main(void) {
    char str[] = "Hello World";
    
    printf("'l' 개수: %d\n", count_char(str, 'l'));  // 3
    printf("'o' 개수: %d\n", count_char(str, 'o'));  // 2
    printf("'x' 개수: %d\n", count_char(str, 'x'));  // 0
    
    return 0;
}
```

---

## 5. 함수에 배열 전달의 진실 (25분)

### 5.1 미스터리 해결

**다시 보는 문제:**
```c
void modifyArray(int arr[3]) {
    arr[0] = 100;  // 원본이 바뀜!
}

int main(void) {
    int numbers[3] = {1, 2, 3};
    modifyArray(numbers);
    printf("%d\n", numbers[0]);  // 100
    return 0;
}
```

**진실**: 배열을 전달하면 **배열 전체가 복사되지 않고**, **첫 번째 원소의 주소만 복사**됩니다!

**즉:**
```c
void modifyArray(int arr[3])
```
는 실제로 다음과 같습니다:
```c
void modifyArray(int *arr)
```

**두 선언은 완전히 동일합니다!**

### 5.2 함수 매개변수에서 배열과 포인터

**다음 네 가지 선언은 모두 같습니다:**
```c
void func(int arr[]);
void func(int arr[10]);     // 크기는 무시됨!
void func(int arr[100]);    // 크기는 무시됨!
void func(int *arr);
```

**컴파일러가 보는 것:**
```c
void func(int *arr)  // 모두 이것으로 변환됨
```

**증명:**
```c
#include <stdio.h>

void print_size_in_func(int arr[]) {
    printf("함수 안: sizeof(arr) = %zu\n", sizeof(arr));  // 8 (포인터 크기)
}

int main(void) {
    int arr[10] = {0};
    
    printf("main: sizeof(arr) = %zu\n", sizeof(arr));  // 40 (10 * 4)
    print_size_in_func(arr);
    
    return 0;
}
```

**출력:**
```
main: sizeof(arr) = 40
함수 안: sizeof(arr) = 8    ← 포인터!
```

### 5.3 스택 프레임으로 이해하기

```c
void modifyArray(int arr[]) {
    arr[0] = 100;
}

int main(void) {
    int numbers[3] = {1, 2, 3};
    modifyArray(numbers);
    return 0;
}
```

**메모리 상태:**
```
modifyArray 호출 시:

┌─────────────────────┐
│ modifyArray 프레임  │
│  arr = 0x1000      │ ← numbers의 주소 (복사본)
│                     │    주소를 통해 원본 접근 가능!
├─────────────────────┤
│ main 프레임         │
│  numbers[3]:        │
│    [1][2][3]        │ ← 원본 배열 (주소 0x1000)
└─────────────────────┘

arr[0] = 100을 실행하면:
→ *(arr + 0) = 100
→ *(0x1000) = 100
→ numbers[0] = 100  ← 원본이 바뀜!
```

**핵심:**
- 배열 이름 `numbers`는 주소
- 함수에 `numbers`를 전달 → 주소가 복사됨
- 함수는 그 주소를 통해 원본 배열에 접근
- **Call by value이지만, 복사된 것이 주소이므로 원본 수정 가능!**

### 5.4 배열 크기 전달하기

**문제**: 함수는 배열 크기를 모름!

```c
void print_array(int arr[]) {
    // sizeof(arr)는 포인터 크기 (8)
    // 배열의 실제 크기를 알 수 없음!
}
```

**해결책**: 크기를 별도 매개변수로 전달

```c
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(void) {
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[3] = {10, 20, 30};
    
    print_array(arr1, 5);
    print_array(arr2, 3);
    
    return 0;
}
```

**관례**: 배열 함수는 거의 항상 크기 매개변수를 가짐

```c
void function(int arr[], int size);
void sort(int arr[], int n);
void initialize(double values[], int count);
```

### 5.5 const로 배열 보호하기

**문제**: 함수가 실수로 배열을 수정할 수 있음

**해결**: `const` 키워드 사용

```c
void print_array(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
        // arr[i] = 0;  // 컴파일 오류! const 배열은 수정 불가
    }
}
```

**장점:**
- 함수가 배열을 수정하지 않음을 보장
- 읽기 전용임을 명시
- 실수 방지

**출처**: [ISO C Standard - const](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.7.3

### 5.6 실습 4: 배열 함수 작성 (15분)

**문제**: 배열의 평균 구하기

```c
#include <stdio.h>

double array_average(int arr[], int size) {
    // 여기에 코드 작성
    // 배열의 모든 원소의 평균 반환
}

int main(void) {
    int scores[] = {85, 90, 78, 92, 88};
    int size = 5;
    
    double avg = array_average(scores, size);
    printf("Average: %.2f\n", avg);  // 86.60
    
    return 0;
}
```

---

## 6. 정리 (10분)

### 핵심 개념 요약

**1. 배열과 포인터의 관계**
```c
int arr[5];

arr          // 첫 번째 원소의 주소
&arr[0]      // 첫 번째 원소의 주소 (위와 같음)
arr[i]       // *(arr + i)와 동일
```

**2. 포인터 산술**
```c
int *ptr = arr;

ptr + 1      // 다음 원소의 주소 (원소 크기만큼 증가)
ptr++        // 다음 원소로 이동
ptr - p2     // 두 포인터 사이의 원소 개수
```

**3. 문자열과 포인터**
```c
char str[] = "Hello";   // 배열 (수정 가능)
char *str = "Hello";    // 포인터 (리터럴은 수정 불가)

while (*str != '\0') { str++; }  // 순회
```

**4. 함수에 배열 전달**
```c
void func(int arr[], int size)  // 실제로는 포인터
void func(int *arr, int size)   // 위와 동일

// 함수 안에서 sizeof(arr)는 포인터 크기
// 따라서 size를 별도로 전달해야 함
```

### 미스터리 완전 해결

**왜 배열은 함수에서 수정될까?**

1. 배열 이름은 주소
2. 함수에 배열 전달 = 주소 전달
3. 주소를 통해 원본에 접근
4. **Call by value이지만, 값이 주소이므로 원본 수정 가능!**

```c
void modify(int n) {
    n = 100;  // 복사본 수정 → 원본 안 바뀜
}

void modifyArray(int arr[]) {  // int *arr와 동일
    arr[0] = 100;  // 주소를 통해 원본 수정 → 원본 바뀜!
}
```

### 다음 시간 예고

**Session 7: 다차원 배열과 포인터**
- 2차원 배열
- 포인터 배열
- 배열 포인터
- 함수 포인터 기초

---

## 참고 자료

### 공식 문서
- [ISO C Standard - Arrays](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.2.1
- [ISO C Standard - Pointer Arithmetic](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.6
- [ISO C Standard - String Functions](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 7.24

### 권장 도서
- Kernighan & Ritchie, "The C Programming Language", Chapter 5
- King, "C Programming: A Modern Approach", Chapter 12

### 온라인 자료
- [Arrays and Pointers - Stanford CS Education Library](http://cslibrary.stanford.edu/106/)
- [Pointer Arithmetic - Carnegie Mellon University](https://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture09.pdf)

---

## 문제 해결 (Troubleshooting)

### 일반적인 문제

**문제 1**: 배열 이름에 ++를 사용
```c
int arr[5];
arr++;  // 컴파일 오류!
```
- **원인**: 배열 이름은 상수 포인터
- **해결**: 별도의 포인터 변수 사용
```c
int *ptr = arr;
ptr++;  // OK
```

**문제 2**: 포인터 타입 불일치
```c
int arr[5];
double *ptr = arr;  // 경고!
```
- **해결**: 포인터 타입을 배열 타입과 일치시키기

**문제 3**: 문자열 리터럴 수정
```c
char *str = "Hello";
str[0] = 'h';  // 세그먼테이션 오류!
```
- **원인**: 문자열 리터럴은 읽기 전용
- **해결**: 배열 사용
```c
char str[] = "Hello";
str[0] = 'h';  // OK
```

**문제 4**: 함수에서 sizeof로 배열 크기 구하기
```c
void func(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // 잘못됨!
}
```
- **원인**: arr은 포인터이므로 sizeof(arr) = 8
- **해결**: 크기를 매개변수로 전달

**문제 5**: 포인터 범위 벗어남
```c
int arr[5];
int *ptr = arr + 10;  // 위험!
*ptr = 100;           // 정의되지 않은 동작
```
- **해결**: 항상 배열 범위 확인

---

**수업 준비물 체크리스트**
□ C 컴파일러 환경  
□ 코드 에디터  
□ 메모리 다이어그램 그릴 도구  
□ 실습 문제 출력본 (선택)  
