# 디버깅 실습 문제
## Breakpoint를 활용하여 버그 찾기

> **목표**: VS Code 디버거를 사용하여 코드의 버그를 찾고 수정하기

---

## 🎯 실습 방법

1. 아래 코드를 복사하여 `.c` 파일로 저장
2. `-g` 옵션으로 컴파일
3. VS Code에서 breakpoint 설정
4. 디버거로 실행하며 변수 값 확인
5. 버그 찾아서 수정
6. 정상 동작 확인

---

## 문제 1: 배열 평균 계산 🐛

**증상**: 평균이 0으로 출력됨

```c
#include <stdio.h>

int main(void) {
    int scores[5] = {85, 92, 78, 95, 88};
    int sum = 0;
    int average;
    
    for (int i = 0; i < 5; i++) {
        sum += scores[i];
    }
    
    average = sum / 5;  // 버그가 여기 있을까요?
    
    printf("평균: %d\n", average);
    
    return 0;
}
```

**디버깅 힌트**
- for 루프 후에 breakpoint
- `sum` 값 확인
- `average` 계산 확인

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 정수 나눗셈으로 소수점 손실

**수정**
```c
double average;
average = sum / 5.0;  // 또는 (double)sum / 5
printf("평균: %.2f\n", average);
```
</details>

---

## 문제 2: 최대값 찾기 🐛🐛

**증상**: 항상 첫 번째 값이 최대값으로 출력됨

```c
#include <stdio.h>

int main(void) {
    int numbers[6] = {23, 45, 67, 12, 89, 34};
    int max = numbers[0];
    
    for (int i = 0; i < 6; i++) {
        if (numbers[i] < max) {  // 버그!
            max = numbers[i];
        }
    }
    
    printf("최대값: %d\n", max);
    
    return 0;
}
```

**디버깅 힌트**
- for 루프 안에 breakpoint
- `i`가 증가하면서 `max` 값이 어떻게 변하는지 확인
- 조건문 검토

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 비교 연산자가 반대

**수정**
```c
if (numbers[i] > max) {  // < 를 > 로 변경
    max = numbers[i];
}
```
</details>

---

## 문제 3: 배열 인덱스 오류 🐛🐛

**증상**: 프로그램이 이상한 값을 출력하거나 충돌함

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    int sum = 0;
    
    for (int i = 1; i <= 5; i++) {  // 버그!
        sum += arr[i];
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    printf("합계: %d\n", sum);
    
    return 0;
}
```

**디버깅 힌트**
- 배열 인덱스 확인
- `i` 값과 배열 크기 비교
- Variables에서 `arr[i]` 값 확인

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 배열 인덱스는 0부터 시작, i=5일 때 범위 초과

**수정**
```c
for (int i = 0; i < 5; i++) {  // 1부터 → 0부터, <= → <
    sum += arr[i];
    printf("arr[%d] = %d\n", i, arr[i]);
}
```
</details>

---

## 문제 4: 팩토리얼 계산 🐛

**증상**: 결과가 항상 0

```c
#include <stdio.h>

int factorial(int n) {
    int result = 0;  // 버그!
    
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    
    return result;
}

int main(void) {
    int num = 5;
    int fact = factorial(num);
    
    printf("%d! = %d\n", num, fact);
    
    return 0;
}
```

**디버깅 힌트**
- factorial 함수에 breakpoint
- F11로 함수 안으로 들어가기
- `result` 초기값 확인
- 첫 번째 반복에서 `result * i` 값 확인

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: result 초기값이 0 (0 × 무엇 = 0)

**수정**
```c
int result = 1;  // 0 → 1로 변경
```
</details>

---

## 문제 5: 문자열 복사 🐛🐛🐛

**증상**: 복사가 제대로 안 됨

```c
#include <stdio.h>

int main(void) {
    char source[] = "Hello";
    char dest[10];
    int i;
    
    for (i = 0; source[i] != '\0'; i++) {
        dest[i] = source[i];
    }
    // 버그: 널 문자를 복사 안 함!
    
    printf("복사된 문자열: %s\n", dest);
    
    return 0;
}
```

**디버깅 힌트**
- for 루프 후에 breakpoint
- `dest` 배열 내용 확인
- 문자열 끝에 무엇이 있어야 하는지 생각

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 널 종료 문자('\0')를 복사하지 않음

**수정**
```c
for (i = 0; source[i] != '\0'; i++) {
    dest[i] = source[i];
}
dest[i] = '\0';  // 추가!
```
</details>

---

## 문제 6: 성적 등급 계산 🐛

**증상**: 90점대도 B 등급으로 나옴

```c
#include <stdio.h>

char getGrade(int score) {
    char grade;
    
    if (score > 90) {  // 버그!
        grade = 'A';
    } else if (score > 80) {
        grade = 'B';
    } else if (score > 70) {
        grade = 'C';
    } else if (score > 60) {
        grade = 'D';
    } else {
        grade = 'F';
    }
    
    return grade;
}

int main(void) {
    int score = 92;
    char grade = getGrade(score);
    
    printf("%d점 -> %c 학점\n", score, grade);
    
    return 0;
}
```

**디버깅 힌트**
- getGrade 함수에 breakpoint
- score=92일 때 조건문 확인
- 90점 정확히는 어떤 등급이어야 할까?

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: `>` 대신 `>=` 사용해야 함 (90점은 A)

**수정**
```c
if (score >= 90) {  // > → >=
    grade = 'A';
} else if (score >= 80) {
    grade = 'B';
} // ... 나머지도 동일
```
</details>

---

## 문제 7: 배열 회전 🐛🐛🐛

**증상**: 배열이 제대로 회전하지 않음

```c
#include <stdio.h>

void rotateRight(int arr[], int size) {
    int temp = arr[size - 1];
    
    for (int i = size - 1; i >= 0; i--) {  // 버그!
        arr[i] = arr[i - 1];
    }
    
    arr[0] = temp;
}

int main(void) {
    int numbers[5] = {1, 2, 3, 4, 5};
    
    printf("원본: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    rotateRight(numbers, 5);
    
    printf("회전 후: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    return 0;
}
```

**디버깅 힌트**
- rotateRight 함수에 breakpoint
- for 루프의 조건 확인
- i=0일 때 `arr[i-1]`은 무엇인가?

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: i=0일 때 arr[-1] 접근 (범위 초과)

**수정**
```c
for (int i = size - 1; i > 0; i--) {  // i >= 0 → i > 0
    arr[i] = arr[i - 1];
}
```
</details>

---

## 문제 8: 소수 판별 🐛🐛

**증상**: 9가 소수로 판정됨

```c
#include <stdio.h>

int isPrime(int n) {
    if (n < 2) {
        return 0;
    }
    
    for (int i = 2; i < n; i++) {
        if (n % i != 0) {  // 버그!
            return 0;  // 소수 아님
        }
    }
    
    return 1;  // 소수
}

int main(void) {
    int num = 9;
    
    if (isPrime(num)) {
        printf("%d는 소수입니다.\n", num);
    } else {
        printf("%d는 소수가 아닙니다.\n", num);
    }
    
    return 0;
}
```

**디버깅 힌트**
- isPrime 함수에 조건부 breakpoint (n==9)
- i=2일 때 조건 확인
- "나누어떨어지지 않으면" vs "나누어떨어지면"

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 조건이 반대 (나누어떨어지면 소수 아님)

**수정**
```c
if (n % i == 0) {  // != → ==
    return 0;  // 나누어떨어지면 소수 아님
}
```
</details>

---

## 문제 9: 버블 정렬 🐛🐛🐛

**증상**: 정렬이 제대로 안 됨

```c
#include <stdio.h>

void bubbleSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - 1; j++) {  // 버그!
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main(void) {
    int numbers[5] = {64, 34, 25, 12, 22};
    
    printf("정렬 전: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    bubbleSort(numbers, 5);
    
    printf("정렬 후: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    return 0;
}
```

**디버깅 힌트**
- 내부 for문 조건 확인
- i=4일 때도 j가 size-1까지 가야 하나?
- 불필요한 비교가 발생하는가?

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 내부 루프가 이미 정렬된 부분도 계속 비교

**수정**
```c
for (int j = 0; j < size - 1 - i; j++) {  // -i 추가
    if (arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
    }
}
```

**설명**: i번째 반복 후 뒤에서 i개는 이미 정렬됨
</details>

---

## 문제 10: 중복 제거 🐛🐛🐛

**증상**: 중복이 완전히 제거되지 않음

```c
#include <stdio.h>

int removeDuplicates(int arr[], int size) {
    int newSize = size;
    
    for (int i = 0; i < newSize; i++) {
        for (int j = i + 1; j < newSize; j++) {
            if (arr[i] == arr[j]) {
                // arr[j] 제거
                for (int k = j; k < newSize - 1; k++) {
                    arr[k] = arr[k + 1];
                }
                newSize--;
                // 버그: j를 감소시키지 않음!
            }
        }
    }
    
    return newSize;
}

int main(void) {
    int numbers[10] = {5, 2, 8, 2, 9, 5, 3, 8, 2, 7};
    
    printf("원본: ");
    for (int i = 0; i < 10; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    int newSize = removeDuplicates(numbers, 10);
    
    printf("중복 제거: ");
    for (int i = 0; i < newSize; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");
    
    return 0;
}
```

**디버깅 힌트**
- 중복 제거 후 j가 어디를 가리켜야 하나?
- 연속된 중복이 있을 때 동작 확인

**정답**
<details>
<summary>클릭하여 보기</summary>

**문제**: 제거 후 j가 다음 요소로 이동하므로 연속 중복을 놓침

**수정**
```c
if (arr[i] == arr[j]) {
    for (int k = j; k < newSize - 1; k++) {
        arr[k] = arr[k + 1];
    }
    newSize--;
    j--;  // 추가! 같은 위치 다시 검사
}
```
</details>

---

## 🎓 디버깅 연습 흐름

### 단계별 접근법

**1단계: 증상 확인**
- 프로그램 실행
- 잘못된 출력 확인

**2단계: 가설 수립**
- "어디가 문제일까?" 예상
- 의심 가는 부분 식별

**3단계: Breakpoint 설정**
- 의심 부분 근처에 breakpoint
- 변수 초기화 부분도 확인

**4단계: 디버깅 실행**
- F5로 시작
- F10으로 한 줄씩 실행
- Variables 창에서 값 확인

**5단계: 원인 파악**
- 예상과 실제 값 비교
- 조건문/반복문 로직 검증

**6단계: 수정 및 검증**
- 코드 수정
- 다시 디버깅하여 확인

---

## 💡 실전 팁

### 효율적인 디버깅

**DO ✅**
- 작은 단위로 테스트
- 변수명을 명확하게
- 조건문은 단순하게
- 경계값 테스트 (0, 1, size-1)

**DON'T ❌**
- printf만으로 디버깅하지 마세요
- 모든 줄에 breakpoint 설정하지 마세요
- 코드를 무작정 수정하지 마세요
- 디버거 없이 "감"으로만 고치지 마세요

---

### 자주 하는 실수 패턴

1. **인덱스 오류**
   - `i <= size` → `i < size`
   - `arr[1]`부터 시작 → `arr[0]`부터

2. **초기값 설정**
   - sum = 1 (곱셈용은 1, 덧셈용은 0)
   - max = 0 (음수 배열이면 틀림)

3. **조건문 반대**
   - `>` vs `>=`
   - `==` vs `!=`

4. **정수 나눗셈**
   - `sum / count` → `sum / (double)count`

5. **무한 루프**
   - 증감식 빠뜨림
   - 종료 조건 오류

---

## 📝 제출 양식

각 문제를 풀고 아래 형식으로 제출하세요:

```
문제 번호: 3

1. 증상
   - 프로그램이 이상한 값 출력

2. 디버깅 과정
   - Breakpoint 위치: 8번 줄 (for 루프)
   - 발견 사항: i=5일 때 arr[5] 접근
   - 원인: 배열 인덱스 범위 초과

3. 수정 내용
   [수정 전]
   for (int i = 1; i <= 5; i++)
   
   [수정 후]
   for (int i = 0; i < 5; i++)

4. 검증
   - 정상 출력 확인: 합계 150

5. 스크린샷
   [Variables 창 캡처]
```

---

**디버깅은 연습이 필요합니다. 포기하지 말고 차근차근 따라가세요!**