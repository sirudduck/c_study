# C Programming Session 5: 메모리와 포인터 기초

## 학습 목표
- 프로그램 메모리 구조 이해 (스택, 힙, 코드, 전역 영역)
- 함수 호출 시 스택 프레임 생성/소멸 과정 이해
- call by value의 한계 이해
- 주소(address)와 포인터(pointer) 개념 학습
- call by reference로 문제 해결
- 포인터 기본 연산 (`&`, `*`) 이해

---

## 1. 동기부여: 함수가 작동하지 않는 문제 (15분)

### 문제: swap 함수가 왜 작동하지 않을까?

**시나리오**: 두 변수의 값을 바꾸고 싶다

```c
#include <stdio.h>

void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("swap 함수 안: a = %d, b = %d\n", a, b);
}

int main(void) {
    int x = 10;
    int y = 20;
    
    printf("swap 호출 전: x = %d, y = %d\n", x, y);
    swap(x, y);
    printf("swap 호출 후: x = %d, y = %d\n", x, y);
    
    return 0;
}
```

**실행 결과:**
```
swap 호출 전: x = 10, y = 20
swap 함수 안: a = 20, b = 10
swap 호출 후: x = 10, y = 20    ← 왜 안 바뀌지?
```

**학생들에게 질문:**
- 함수 안에서는 값이 바뀌는데, 왜 `main`의 `x`, `y`는 안 바뀔까?
- `a`, `b`와 `x`, `y`는 같은 변수일까, 다른 변수일까?
- 함수가 끝나면 `a`, `b`는 어떻게 될까?

**다른 예시: 값을 증가시키는 함수**
```c
void increment(int n) {
    n = n + 1;
    printf("함수 안: n = %d\n", n);
}

int main(void) {
    int count = 5;
    printf("호출 전: count = %d\n", count);
    increment(count);
    printf("호출 후: count = %d\n", count);  // 여전히 5!
    return 0;
}
```

**핵심 질문**: 
- 왜 함수가 원본 변수를 바꾸지 못할까?
- 어떻게 해야 함수가 원본을 바꿀 수 있을까?

**오늘의 목표**: 이 문제를 해결하기 위해 메모리가 어떻게 작동하는지 이해하자!

---

## 2. 프로그램 메모리 구조 개관 (15분)

### 2.1 메모리의 4가지 영역

프로그램이 실행되면 메모리는 4개 영역으로 나뉩니다:

```
높은 주소
┌─────────────────┐
│     스택        │ ← 함수 호출, 지역 변수
│  (Stack)        │   (위에서 아래로 성장)
│       ↓         │
├─────────────────┤
│                 │ ← 빈 공간
├─────────────────┤
│       ↑         │
│     힙          │ ← 동적 할당 (malloc 등)
│   (Heap)        │   (아래서 위로 성장)
├─────────────────┤
│  전역/정적 영역  │ ← 전역 변수, static 변수
│   (Data)        │
├─────────────────┤
│  코드 영역       │ ← 프로그램 코드
│   (Code/Text)   │
└─────────────────┘
낮은 주소
```

**각 영역의 역할:**

1. **코드 영역 (Code/Text)**
   - 프로그램의 명령어(코드) 저장
   - 읽기 전용 (변경 불가)
   - 프로그램 시작부터 종료까지 유지

2. **전역/정적 영역 (Data)**
   - 전역 변수, static 변수 저장
   - 프로그램 시작부터 종료까지 유지
   - 초기화된 데이터와 초기화 안 된 데이터(BSS) 구분

3. **힙 영역 (Heap)**
   - 동적 할당 메모리 (`malloc`, `calloc` 등)
   - 프로그래머가 수동으로 할당/해제
   - 아래에서 위로 성장
   - **오늘은 다루지 않음** (추후 학습)

4. **스택 영역 (Stack)**
   - **오늘의 주인공!**
   - 함수 호출 정보 저장
   - 지역 변수, 매개변수 저장
   - 함수가 끝나면 자동으로 정리
   - 위에서 아래로 성장

**출처**: 
- [ISO C Standard - Memory Layout](https://www.iso.org/standard/74528.html)
- Kernighan & Ritchie, "The C Programming Language", Chapter 5

### 2.2 함수는 어디에 저장될까?

**질문**: 우리가 작성한 함수 코드는 메모리 어디에 있을까?

**답**: 함수의 코드(명령어)는 **코드 영역**에 저장됩니다!

**구분해야 할 것:**

1. **함수의 코드 자체** → 코드 영역
2. **함수 실행 시 생성되는 변수들** → 스택

**예시로 이해하기:**
```c
int add(int a, int b) {    // ← 이 함수 코드는 코드 영역에
    int sum = a + b;       // ← sum은 스택에 (호출될 때만)
    return sum;
}

int main(void) {           // ← main 함수 코드도 코드 영역에
    int result = add(5, 3); // ← result는 스택에
    return 0;
}
```

**메모리 상태:**
```
[ 프로그램 로딩 시 ]
┌─────────────────┐
│  코드 영역      │
│  - main() 명령어│ ← 컴파일된 기계어 코드
│  - add() 명령어 │ ← 컴파일된 기계어 코드
│                 │
│  (프로그램 시작부터 종료까지 유지)
└─────────────────┘

[ add(5, 3) 호출 시 ]
┌─────────────────┐
│ 스택            │
│ add 프레임:     │ ← 실행 중에만 생성!
│  a = 5          │
│  b = 3          │
│  sum = 8        │
├─────────────────┤
│ main 프레임     │
│  result         │
└─────────────────┘
│
│ (함수 종료 시 프레임 사라짐)
│
┌─────────────────┐
│  코드 영역      │
│  - main() 명령어│ ← 여전히 존재
│  - add() 명령어 │ ← 여전히 존재
└─────────────────┘
```

**핵심 차이:**

| 항목 | 코드 영역 | 스택 |
|------|-----------|------|
| **저장 내용** | 함수 명령어 (코드) | 함수 실행 데이터 (변수) |
| **생성 시점** | 프로그램 로딩 시 | 함수 호출 시 |
| **소멸 시점** | 프로그램 종료 시 | 함수 종료 시 |
| **수정 가능?** | 불가능 (읽기 전용) | 가능 |

**비유:**
```
코드 영역 = 요리 레시피 (책에 인쇄됨, 바뀌지 않음)
스택     = 실제 요리 재료 (사용하고 버림)
```

**함수 주소 확인해보기:**
```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main(void) {
    printf("add 함수 주소: %p\n", (void*)add);
    printf("main 함수 주소: %p\n", (void*)main);
    
    int x = 10;
    printf("변수 x 주소: %p\n", (void*)&x);
    
    return 0;
}
```

**출력 예시:**
```
add 함수 주소: 0x400526     ← 낮은 주소 (코드 영역)
main 함수 주소: 0x400546    ← 낮은 주소 (코드 영역)
변수 x 주소: 0x7ffc1234abcd ← 높은 주소 (스택)
```

**관찰:**
- 함수 주소는 매우 낮은 값 → 코드 영역
- 변수 주소는 높은 값 → 스택
- 함수 주소는 실행할 때마다 **같음** (고정됨)
- 변수 주소는 실행할 때마다 **다를 수 있음**

**정리:**
```
int add(int a, int b) { ... }

┌─ 함수 코드 (add)    → 코드 영역 (프로그램 전체에서 하나)
│
└─ 매개변수 a, b      → 스택 (호출될 때마다 새로 생성)
```

---

## 2.5 자료형과 메모리 크기 (15분)

### 2.5.1 왜 자료형 크기를 알아야 할까?

포인터를 제대로 이해하려면 **각 자료형이 메모리에서 차지하는 크기**를 알아야 합니다.

**미리보기 - 나중에 배울 내용:**
```c
int arr[3] = {10, 20, 30};
int *ptr = arr;

ptr + 1  // 다음 원소로 이동 - 몇 바이트 이동?
```

**답: 4바이트 이동** (int가 4바이트이므로)

이걸 이해하려면 먼저 자료형 크기를 알아야 합니다!

### 2.5.2 sizeof 연산자

**정의**: 자료형이나 변수의 크기를 바이트 단위로 반환

**문법:**
```c
sizeof(자료형)
sizeof(변수)
sizeof 변수  // 괄호 생략 가능
```

**반환 타입**: `size_t` (부호 없는 정수, 보통 `unsigned long`)

**예시:**
```c
#include <stdio.h>

int main(void) {
    printf("sizeof(char) = %zu\n", sizeof(char));
    printf("sizeof(int) = %zu\n", sizeof(int));
    
    int x = 10;
    printf("sizeof(x) = %zu\n", sizeof(x));
    printf("sizeof x = %zu\n", sizeof x);  // 괄호 생략
    
    return 0;
}
```

**주의**: `%zu`는 `size_t`를 출력하는 포맷 지정자입니다.

**출처**: [ISO C Standard - sizeof](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.3.4

### 2.5.3 기본 자료형의 크기

**일반적인 64비트 시스템 (Linux, macOS, Windows):**

| 자료형 | 크기 (바이트) | 비트 수 | 범위 |
|--------|--------------|---------|------|
| `char` | 1 | 8 | -128 ~ 127 |
| `unsigned char` | 1 | 8 | 0 ~ 255 |
| `short` | 2 | 16 | -32,768 ~ 32,767 |
| `unsigned short` | 2 | 16 | 0 ~ 65,535 |
| `int` | 4 | 32 | -2,147,483,648 ~ 2,147,483,647 |
| `unsigned int` | 4 | 32 | 0 ~ 4,294,967,295 |
| `long` | 8 (Linux/Mac), 4 (Windows) | 64/32 | 시스템 의존적 |
| `long long` | 8 | 64 | -9,223,372,036,854,775,808 ~ ... |
| `float` | 4 | 32 | 약 ±3.4 × 10^38 |
| `double` | 8 | 64 | 약 ±1.7 × 10^308 |

**중요**: 
- C 표준은 **최소 크기**만 보장
- 실제 크기는 **시스템과 컴파일러에 따라 다름**
- **항상 `sizeof`로 확인**하는 습관!

**출처**: [ISO C Standard - Integer Types](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.2.5

### 2.5.4 포인터의 크기

**핵심**: 포인터의 크기는 **가리키는 타입과 무관**

```c
#include <stdio.h>

int main(void) {
    printf("char* 크기: %zu\n", sizeof(char*));
    printf("int* 크기: %zu\n", sizeof(int*));
    printf("double* 크기: %zu\n", sizeof(double*));
    
    return 0;
}
```

**출력 (64비트 시스템):**
```
char* 크기: 8
int* 크기: 8
double* 크기: 8
```

**출력 (32비트 시스템):**
```
char* 크기: 4
int* 크기: 4
double* 크기: 4
```

**이유**: 포인터는 **메모리 주소**를 저장
- 64비트 시스템 → 주소 크기 64비트 = 8바이트
- 32비트 시스템 → 주소 크기 32비트 = 4바이트

**수학적 표현:**
```
포인터 크기 = 주소 공간 크기
64비트: 2^64 = 18,446,744,073,709,551,616 바이트 주소 가능
32비트: 2^32 = 4,294,967,296 바이트 = 4GB 주소 가능
```

### 2.5.5 배열과 크기

**배열의 전체 크기:**
```c
int arr[5];
sizeof(arr)  // 5 * sizeof(int) = 5 * 4 = 20 바이트
```

**배열 원소 개수 구하기:**
```c
int arr[5];
int size = sizeof(arr) / sizeof(arr[0]);
// = 20 / 4 = 5
```

**주의: 포인터로 전달된 배열**
```c
void func(int arr[]) {
    // arr은 실제로 포인터!
    int size = sizeof(arr) / sizeof(arr[0]);  // 잘못됨!
    // = 8 / 4 = 2 (64비트 시스템)
}
```

### 2.5.6 실습: 자료형 크기 확인하기 (10분)

**문제**: 다음 코드를 실행하고 결과를 확인하세요

```c
#include <stdio.h>

int main(void) {
    // 기본 자료형
    printf("=== 기본 자료형 크기 ===\n");
    printf("char: %zu 바이트\n", sizeof(char));
    printf("short: %zu 바이트\n", sizeof(short));
    printf("int: %zu 바이트\n", sizeof(int));
    printf("long: %zu 바이트\n", sizeof(long));
    printf("long long: %zu 바이트\n", sizeof(long long));
    printf("float: %zu 바이트\n", sizeof(float));
    printf("double: %zu 바이트\n", sizeof(double));
    
    // 포인터
    printf("\n=== 포인터 크기 ===\n");
    printf("char*: %zu 바이트\n", sizeof(char*));
    printf("int*: %zu 바이트\n", sizeof(int*));
    printf("double*: %zu 바이트\n", sizeof(double*));
    
    // 배열
    printf("\n=== 배열 크기 ===\n");
    int arr[10];
    printf("int arr[10]: %zu 바이트\n", sizeof(arr));
    printf("원소 개수: %zu\n", sizeof(arr) / sizeof(arr[0]));
    
    // 구조체 (미리보기)
    printf("\n=== 복합 자료형 ===\n");
    struct {
        char c;
        int i;
        double d;
    } s;
    printf("struct 크기: %zu 바이트\n", sizeof(s));
    
    return 0;
}
```

**확인할 점:**
1. 여러분의 시스템에서 각 자료형 크기는?
2. 포인터 크기는 모두 같은가?
3. 배열 크기는 (원소 크기 × 개수)인가?
4. 구조체 크기는 모든 멤버 크기의 합인가? (아닐 수도 있음 - 패딩)

### 2.5.7 왜 이게 중요한가?

**포인터 산술 연산 미리보기:**

```c
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;  // ptr은 arr[0]을 가리킴

// ptr + 1은 어디를 가리킬까?
// → arr[1]을 가리킴
// → 주소가 sizeof(int) = 4바이트 증가!
```

**메모리 레이아웃:**
```
주소        값
0x1000:    [10]  ← ptr (arr[0])
0x1004:    [20]  ← ptr + 1 (arr[1])
0x1008:    [30]  ← ptr + 2 (arr[2])
0x100C:    [40]  ← ptr + 3 (arr[3])
0x1010:    [50]  ← ptr + 4 (arr[4])

ptr + 1의 주소 = 0x1000 + sizeof(int)
              = 0x1000 + 4
              = 0x1004
```

**다른 자료형:**
```c
double arr[3];
double *ptr = arr;

// ptr + 1의 주소 = ptr의 주소 + sizeof(double)
//                = ptr의 주소 + 8
```

**핵심**: 포인터 + 1은 **1바이트 증가가 아니라**, **가리키는 자료형 크기만큼 증가**

이 개념은 섹션 6 (포인터와 배열)에서 자세히 배웁니다!

---

## 3. 함수 호출과 스택 프레임 (30분)

### 3.1 스택이란?

**자료구조로서의 스택:**
- LIFO (Last In, First Out): 마지막에 들어간 것이 먼저 나옴
- 접시 쌓기와 유사

```
수학적 표현:
Stack S = {e₁, e₂, ..., eₙ}
Push(x): S ← S ∪ {x}
Pop(): x ← eₙ, S ← S \ {eₙ}
```

**프로그램 스택의 역할:**
- 함수 호출 시 정보 저장
- 함수 종료 시 정보 제거
- 자동으로 관리됨 (프로그래머가 신경 쓸 필요 없음)

**예시 시각화:**
```
함수 호출 전:
┌─────────┐
│         │
└─────────┘

funcA() 호출:
┌─────────┐
│ funcA   │ ← 새로 추가
└─────────┘

funcB() 호출:
┌─────────┐
│ funcB   │ ← 새로 추가
├─────────┤
│ funcA   │
└─────────┘

funcB() 종료:
┌─────────┐
│ funcA   │ ← funcB 제거됨
└─────────┘

funcA() 종료:
┌─────────┐
│         │ ← funcA도 제거됨
└─────────┘
```

### 3.2 스택 프레임이란?

**정의**: 함수가 호출될 때 스택에 생성되는 메모리 블록

**스택 프레임에 저장되는 것:**
1. 매개변수 (parameters)
2. 리턴 주소 (return address) - 함수 종료 후 돌아갈 위치
3. 지역 변수 (local variables)
4. 이전 프레임 포인터 (saved frame pointer)

**중요**: 각 함수 호출마다 **독립적인** 스택 프레임 생성!

### 3.3 간단한 예제로 스택 추적하기

**코드:**
```c
#include <stdio.h>

void funcB(int p) {
    int local_b = p * 2;
    printf("funcB: p = %d, local_b = %d\n", p, local_b);
}

void funcA(int x) {
    int local_a = x + 10;
    printf("funcA: x = %d, local_a = %d\n", x, local_a);
    funcB(local_a);
}

int main(void) {
    int num = 5;
    printf("main: num = %d\n", num);
    funcA(num);
    printf("main 종료\n");
    return 0;
}
```

**스택 변화 과정 시각화:**

```
Step 1: main 시작
┌─────────────────┐
│ main 프레임     │
│  num = 5        │
└─────────────────┘

Step 2: funcA(5) 호출
┌─────────────────┐
│ funcA 프레임    │
│  x = 5          │ ← num 값이 복사됨
│  local_a = 15   │
├─────────────────┤
│ main 프레임     │
│  num = 5        │
└─────────────────┘

Step 3: funcB(15) 호출
┌─────────────────┐
│ funcB 프레임    │
│  p = 15         │ ← local_a 값이 복사됨
│  local_b = 30   │
├─────────────────┤
│ funcA 프레임    │
│  x = 5          │
│  local_a = 15   │
├─────────────────┤
│ main 프레임     │
│  num = 5        │
└─────────────────┘

Step 4: funcB 종료
┌─────────────────┐
│ funcA 프레임    │ ← funcB 프레임 제거됨
│  x = 5          │
│  local_a = 15   │
├─────────────────┤
│ main 프레임     │
│  num = 5        │
└─────────────────┘

Step 5: funcA 종료
┌─────────────────┐
│ main 프레임     │ ← funcA 프레임 제거됨
│  num = 5        │
└─────────────────┘

Step 6: main 종료
┌─────────────────┐
│                 │ ← 모든 프레임 제거됨
└─────────────────┘
```

**핵심 관찰:**
- 각 함수는 **독립적인** 스택 프레임을 가짐
- 매개변수는 **값이 복사**되어 전달됨
- 함수 종료 시 스택 프레임 **자동 제거**

### 3.4 실습 1: 스택 변화 추적하기 (10분)

**문제**: 다음 코드의 스택 변화를 단계별로 그려보세요

```c
#include <stdio.h>

int add(int a, int b) {
    int sum = a + b;
    return sum;
}

int calculate(int x) {
    int result = add(x, 10);
    return result;
}

int main(void) {
    int value = 5;
    int answer = calculate(value);
    printf("Answer: %d\n", answer);
    return 0;
}
```

**과제**: 
1. 각 함수 호출 시점의 스택 프레임을 그리세요
2. 각 프레임에 어떤 변수들이 있는지 적으세요
3. 함수 종료 시 어떤 프레임이 제거되는지 표시하세요

**힌트**: 총 4단계로 나누어 그리세요
- main 시작
- calculate 호출
- add 호출
- add 종료, calculate 종료, main 종료

---

## 4. Call by Value의 이해 (20분)

### 4.1 Call by Value란?

**정의**: 함수 호출 시 **값이 복사**되어 전달되는 방식

C 언어의 기본 매개변수 전달 방식입니다.

**원리:**
```c
void func(int param) {
    // param은 원본의 복사본
}

int main(void) {
    int original = 10;
    func(original);  // original의 값이 복사되어 param에 전달
    return 0;
}
```

**메모리 관점:**
```
main 프레임:
┌──────────────────┐
│ original = 10    │ ← 원본
└──────────────────┘

func 호출 시:
┌──────────────────┐
│ func 프레임      │
│  param = 10      │ ← 복사본 (독립적)
├──────────────────┤
│ main 프레임      │
│  original = 10   │ ← 원본
└──────────────────┘
```

**수학적 비유:**
```
f(x) = x + 1

x = 5일 때 f(x)를 계산하면:
- 함수 내부에서는 x = 5를 사용
- 하지만 함수 밖의 x는 여전히 5
```

### 4.2 왜 swap이 작동하지 않는가?

**다시 보는 swap 함수:**
```c
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main(void) {
    int x = 10;
    int y = 20;
    swap(x, y);
    // x, y는 여전히 10, 20
    return 0;
}
```

**스택 프레임 분석:**
```
Step 1: swap 호출 전
┌──────────────────┐
│ main 프레임      │
│  x = 10          │ ← 원본
│  y = 20          │ ← 원본
└──────────────────┘

Step 2: swap(x, y) 호출
┌──────────────────┐
│ swap 프레임      │
│  a = 10          │ ← x의 복사본
│  b = 20          │ ← y의 복사본
│  temp            │
├──────────────────┤
│ main 프레임      │
│  x = 10          │ ← 원본 (변경 안 됨!)
│  y = 20          │ ← 원본 (변경 안 됨!)
└──────────────────┘

Step 3: swap 내부에서 교환
┌──────────────────┐
│ swap 프레임      │
│  a = 20          │ ← 복사본만 바뀜
│  b = 10          │ ← 복사본만 바뀜
│  temp = 10       │
├──────────────────┤
│ main 프레임      │
│  x = 10          │ ← 원본은 그대로!
│  y = 20          │ ← 원본은 그대로!
└──────────────────┘

Step 4: swap 종료 (프레임 제거)
┌──────────────────┐
│ main 프레임      │
│  x = 10          │ ← 여전히 10
│  y = 20          │ ← 여전히 20
└──────────────────┘
```

**결론**: 
- `a`, `b`는 `x`, `y`의 **복사본**
- 복사본을 바꿔도 원본은 안 바뀜
- 함수가 끝나면 복사본은 사라짐

### 4.3 Call by Value의 장단점

**장점:**
- 안전함: 함수가 원본을 못 바꿈
- 예측 가능: 함수 호출 후 원본은 항상 그대로
- 독립성: 함수 내부가 외부에 영향 안 줌

**단점:**
- 원본을 바꾸고 싶을 때 못 바꿈
- 큰 데이터 복사 시 성능 저하 (오늘은 다루지 않음)

### 4.4 실습 2: Call by Value 확인하기 (10분)

**문제**: 다음 코드를 실행하고 결과를 예측해보세요

```c
#include <stdio.h>

void modify(int n) {
    n = n * 2;
    printf("함수 안: n = %d\n", n);
}

void modifyArray(int arr[3]) {
    arr[0] = 100;
    printf("함수 안: arr[0] = %d\n", arr[0]);
}

int main(void) {
    int x = 5;
    printf("호출 전: x = %d\n", x);
    modify(x);
    printf("호출 후: x = %d\n", x);
    
    int numbers[3] = {1, 2, 3};
    printf("호출 전: numbers[0] = %d\n", numbers[0]);
    modifyArray(numbers);
    printf("호출 후: numbers[0] = %d\n", numbers[0]);
    
    return 0;
}
```

**질문:**
1. `x`는 바뀔까요?
2. `numbers[0]`는 바뀔까요? (힌트: 배열은 특별함!)
3. 왜 다르게 작동할까요?

**실행해보고 결과를 비교하세요!**

---

## 5. 주소와 포인터 개념 (25분)

### 5.1 메모리 주소란?

**비유**: 메모리는 거대한 아파트

```
아파트 = 메모리
각 호수 = 주소 (address)
각 집 = 메모리 공간 (변수)
```

**메모리 주소:**
- 메모리의 각 바이트는 고유한 번호(주소)를 가짐
- 변수는 특정 주소에 저장됨
- 주소는 보통 16진수로 표현 (예: `0x7ffeab123`)`

**시각화:**
```
주소        값
0x1000:    [  10  ]  ← int x = 10;
0x1004:    [  20  ]  ← int y = 20;
0x1008:    [  30  ]  ← int z = 30;
```

### 5.2 주소 연산자 `&`

**정의**: 변수의 주소를 얻는 연산자

**문법:**
```c
int x = 10;
printf("x의 값: %d\n", x);         // 10
printf("x의 주소: %p\n", &x);      // 0x7ffeab123 (예시)
```

**`&` 연산자:**
- "~의 주소" (address of)
- 변수 앞에 붙임
- 주소 값 반환

**예시:**
```c
int num = 42;
int *ptr;  // 포인터 변수 (아래에서 설명)

printf("num = %d\n", num);           // 값: 42
printf("&num = %p\n", &num);         // 주소: 0x7ffeab100 (예시)
```

**출처**: [ISO C Standard - Address Operator](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.3.2

### 5.3 포인터 변수

**정의**: 주소를 저장하는 변수

**선언:**
```c
int *ptr;     // int를 가리키는 포인터
double *dptr; // double을 가리키는 포인터
char *cptr;   // char를 가리키는 포인터
```

**포인터 변수의 의미:**
- `int *ptr`: "ptr은 int의 주소를 담는 변수"
- `*`는 "포인터"를 의미
- 타입이 중요: `int*`, `double*`, `char*`는 다름

**사용:**
```c
int x = 10;
int *ptr;      // 포인터 선언
ptr = &x;      // x의 주소를 ptr에 저장
```

**메모리 상태:**
```
주소        변수      값
0x1000:    x         10
0x2000:    ptr       0x1000  ← x의 주소를 담고 있음
```

**시각화:**
```
x = 10
[   10   ]  ← 변수 x
   ↑
   │
   │ ptr이 가리킴
   │
[ 0x1000 ]  ← 포인터 ptr (x의 주소 저장)
```

### 5.4 간접 참조 연산자 `*`

**정의**: 포인터가 가리키는 곳의 값에 접근하는 연산자

**주의**: 선언의 `*`와 다름!
- 선언: `int *ptr;` → "포인터 변수"
- 사용: `*ptr` → "포인터가 가리키는 값"

**문법:**
```c
int x = 10;
int *ptr = &x;   // ptr은 x를 가리킴

printf("%d\n", *ptr);   // 10 출력 (x의 값)
*ptr = 20;              // x를 20으로 변경
printf("%d\n", x);      // 20 출력
```

**연산자 정리:**
```c
int x = 10;
int *ptr = &x;

x        // x의 값 (10)
&x       // x의 주소 (0x1000)
ptr      // ptr의 값 = x의 주소 (0x1000)
*ptr     // ptr이 가리키는 값 (10) = x의 값
&ptr     // ptr의 주소 (0x2000)
```

**메모리 시각화:**
```
주소        변수      값          설명
0x1000:    x         10         원본 변수
0x2000:    ptr       0x1000     x의 주소 저장

*ptr → ptr에 저장된 주소(0x1000)로 가서 그 값(10)을 가져옴
```

**출처**: [ISO C Standard - Indirection Operator](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.3.2

### 5.5 실습 3: 주소와 포인터 기초 (15분)

**문제 1**: 주소 출력해보기

```c
#include <stdio.h>

int main(void) {
    int a = 10;
    int b = 20;
    int c = 30;
    
    printf("a의 값: %d, 주소: %p\n", a, &a);
    printf("b의 값: %d, 주소: %p\n", b, &b);
    printf("c의 값: %d, 주소: %p\n", c, &c);
    
    return 0;
}
```

**관찰할 점:**
- 주소 값은 실행할 때마다 다를 수 있음
- 변수들의 주소가 연속적인가?

---

**문제 2**: 포인터로 값 바꾸기

```c
#include <stdio.h>

int main(void) {
    int x = 100;
    int *ptr = &x;
    
    printf("x = %d\n", x);
    printf("*ptr = %d\n", *ptr);
    
    *ptr = 200;  // 포인터를 통해 x 변경
    
    printf("변경 후 x = %d\n", x);
    printf("변경 후 *ptr = %d\n", *ptr);
    
    return 0;
}
```

**확인할 점:**
- `*ptr = 200`을 하면 `x`도 바뀌는가?
- 왜 그런가?

---

**문제 3**: 빈칸 채우기

다음 코드의 출력을 예측하고, 빈칸을 채우세요:

```c
#include <stdio.h>

int main(void) {
    int num = 50;
    int *p = &num;
    
    printf("num = %d\n", num);           // 출력: ___?___
    printf("*p = %d\n", *p);             // 출력: ___?___
    
    *p = *p + 10;
    
    printf("num = %d\n", num);           // 출력: ___?___
    printf("*p = %d\n", *p);             // 출력: ___?___
    
    num = 100;
    
    printf("num = %d\n", num);           // 출력: ___?___
    printf("*p = %d\n", *p);             // 출력: ___?___
    
    return 0;
}
```

---

## 6. Call by Reference로 문제 해결 (25분)

### 6.1 Call by Reference란?

**정의**: 함수에 **주소를 전달**하여 원본을 직접 수정할 수 있게 하는 방식

**핵심 아이디어:**
- 값을 복사하는 대신, **주소를 복사**
- 주소를 통해 원본에 접근
- 원본을 직접 수정 가능

**용어 주의**: 
C 언어는 엄밀히 말하면 "call by value"만 지원하지만, 포인터를 사용하면 "call by reference"처럼 동작할 수 있습니다. 이를 "포인터를 이용한 call by reference 흉내내기"라고도 합니다.

### 6.2 swap 함수 수정하기

**이전 버전 (작동 안 함):**
```c
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main(void) {
    int x = 10, y = 20;
    swap(x, y);  // x, y 변경 안 됨
    return 0;
}
```

**새 버전 (포인터 사용):**
```c
void swap(int *a, int *b) {  // 포인터 매개변수
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void) {
    int x = 10, y = 20;
    swap(&x, &y);  // 주소 전달
    printf("x = %d, y = %d\n", x, y);  // x = 20, y = 10
    return 0;
}
```

**차이점:**
```c
// Call by value:
void swap(int a, int b)     // 값을 받음
swap(x, y);                  // 값을 보냄

// Call by reference (포인터 이용):
void swap(int *a, int *b)   // 주소를 받음
swap(&x, &y);               // 주소를 보냄
```

### 6.3 스택 프레임으로 이해하기

**Call by value (작동 안 함):**
```
swap 호출 시:
┌──────────────────┐
│ swap 프레임      │
│  a = 10          │ ← x의 복사본
│  b = 20          │ ← y의 복사본
├──────────────────┤
│ main 프레임      │
│  x = 10          │ ← 원본
│  y = 20          │ ← 원본
└──────────────────┘

a, b를 바꿔도 x, y는 안 바뀜!
```

**Call by reference (작동함):**
```
swap 호출 시:
┌──────────────────┐
│ swap 프레임      │
│  a = 0x1000      │ ← x의 주소 (복사본)
│  b = 0x1004      │ ← y의 주소 (복사본)
├──────────────────┤
│ main 프레임      │
│  x = 10          │ ← 주소 0x1000
│  y = 20          │ ← 주소 0x1004
└──────────────────┘

*a, *b를 통해 x, y에 직접 접근 가능!
```

**단계별 시각화:**
```
Step 1: swap(&x, &y) 호출
┌──────────────────┐
│ swap 프레임      │
│  a → [0x1000]    │ ───┐
│  b → [0x1004]    │ ───┼─┐
├──────────────────┤    │ │
│ main 프레임      │    │ │
│  x = 10  [0x1000]│ ←──┘ │
│  y = 20  [0x1004]│ ←────┘
└──────────────────┘

Step 2: temp = *a (x의 값 읽기)
┌──────────────────┐
│ swap 프레임      │
│  a → [0x1000]    │ ─→ x = 10
│  b → [0x1004]    │
│  temp = 10       │
├──────────────────┤
│ main 프레임      │
│  x = 10          │
│  y = 20          │
└──────────────────┘

Step 3: *a = *b (x에 y의 값 쓰기)
┌──────────────────┐
│ swap 프레임      │
│  a → [0x1000]    │ ─→ x = 20 (변경!)
│  b → [0x1004]    │
│  temp = 10       │
├──────────────────┤
│ main 프레임      │
│  x = 20          │ ← 변경됨!
│  y = 20          │
└──────────────────┘

Step 4: *b = temp (y에 temp 값 쓰기)
┌──────────────────┐
│ swap 프레임      │
│  a → [0x1000]    │
│  b → [0x1004]    │ ─→ y = 10 (변경!)
│  temp = 10       │
├──────────────────┤
│ main 프레임      │
│  x = 20          │
│  y = 10          │ ← 변경됨!
└──────────────────┘
```

**핵심:**
- 주소(복사본)를 통해 원본에 접근
- 원본을 직접 수정 가능

### 6.4 다른 예제: increment 함수

**Call by value (작동 안 함):**
```c
void increment(int n) {
    n = n + 1;
}

int main(void) {
    int count = 5;
    increment(count);
    printf("%d\n", count);  // 5 (변경 안 됨)
    return 0;
}
```

**Call by reference (작동함):**
```c
void increment(int *n) {
    *n = *n + 1;  // 또는 (*n)++
}

int main(void) {
    int count = 5;
    increment(&count);
    printf("%d\n", count);  // 6 (변경됨!)
    return 0;
}
```

### 6.5 실습 4: swap과 call by reference (15분)

**문제 1**: swap 함수 완성하기

다음 코드의 빈칸을 채워서 swap 함수를 완성하세요:

```c
#include <stdio.h>

void swap(_______ a, _______ b) {
    int temp = _______;
    _______ = _______;
    _______ = temp;
}

int main(void) {
    int x = 100;
    int y = 200;
    
    printf("swap 전: x = %d, y = %d\n", x, y);
    swap(_______, _______);
    printf("swap 후: x = %d, y = %d\n", x, y);
    
    return 0;
}
```

**목표 출력:**
```
swap 전: x = 100, y = 200
swap 후: x = 200, y = 100
```

---

**문제 2**: 배열 원소 교환

배열의 두 원소를 교환하는 함수를 작성하세요:

```c
#include <stdio.h>

void swap_array_elements(int *a, int *b) {
    // 여기에 코드 작성
}

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    printf("교환 전: arr[0] = %d, arr[3] = %d\n", arr[0], arr[3]);
    swap_array_elements(&arr[0], &arr[3]);
    printf("교환 후: arr[0] = %d, arr[3] = %d\n", arr[0], arr[3]);
    
    return 0;
}
```

---

**문제 3**: 두 수를 더하고 곱하기

하나의 함수로 두 수의 합과 곱을 동시에 구하세요:

```c
#include <stdio.h>

void calculate(int a, int b, int *sum, int *product) {
    // 여기에 코드 작성
    // *sum에 a + b 저장
    // *product에 a * b 저장
}

int main(void) {
    int x = 5, y = 3;
    int sum, product;
    
    calculate(x, y, &sum, &product);
    
    printf("%d + %d = %d\n", x, y, sum);
    printf("%d * %d = %d\n", x, y, product);
    
    return 0;
}
```

**목표 출력:**
```
5 + 3 = 8
5 * 3 = 15
```

---

## 7. 정리 및 비교 (10분)

### 7.1 Call by Value vs Call by Reference 비교

| 특성 | Call by Value | Call by Reference |
|------|---------------|-------------------|
| 매개변수 | 값 | 주소 (포인터) |
| 호출 방법 | `func(x)` | `func(&x)` |
| 함수 정의 | `void func(int a)` | `void func(int *a)` |
| 값 접근 | `a` | `*a` |
| 원본 수정 | 불가능 | 가능 |
| 안전성 | 높음 | 낮음 (실수 가능) |
| 용도 | 값만 필요할 때 | 원본 수정 필요할 때 |

### 7.2 언제 무엇을 사용할까?

**Call by Value 사용:**
- 값만 읽어서 계산
- 원본 보호 필요
- 작은 데이터 (int, char 등)

**예시:**
```c
int square(int n) {
    return n * n;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}
```

**Call by Reference 사용:**
- 원본을 수정해야 할 때
- 여러 값을 반환해야 할 때 (return은 하나만 가능)
- 큰 데이터 전달 (배열, 구조체 - 추후 학습)

**예시:**
```c
void swap(int *a, int *b) {
    // 원본 수정
}

void get_min_max(int arr[], int size, int *min, int *max) {
    // 여러 값 반환
}
```

### 7.3 핵심 개념 정리

**메모리 구조:**
- 스택: 함수 호출 시 자동 관리
- 스택 프레임: 함수마다 독립적인 공간

**함수 호출:**
- Call by value: 값 복사 → 원본 보호
- Call by reference: 주소 전달 → 원본 수정 가능

**포인터:**
- `&`: 주소 얻기
- `*`: 포인터 선언 또는 간접 참조
- 포인터 = 주소를 담는 변수

---

## 8. 다음 시간 예고 (5분)

### 다음 주제: 포인터와 배열

**배울 내용:**
- 배열 이름과 포인터의 관계
- 포인터 산술 연산
- 배열 순회를 포인터로 하기
- 포인터로 문자열 다루기 (char 배열)
- 함수에 배열 전달의 진실

**미리 생각해볼 질문:**
- 왜 `modifyArray` 함수에서는 배열이 바뀌었을까? (실습 2 참고)
- `arr[i]`와 `*(arr + i)`는 같을까?
- 배열 이름은 포인터일까?

---

## 참고 자료

### 공식 문서
- [ISO C Standard (C11)](https://www.iso.org/standard/57853.html)
- [ISO C Standard - Pointers](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 6.5.3.2, 6.5.6

### 권장 도서
- Kernighan & Ritchie, "The C Programming Language", 2nd Edition, Chapter 5
- King, "C Programming: A Modern Approach", 2nd Edition, Chapter 11-12

### 온라인 자료
- [C Pointers - Carnegie Mellon University](https://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture08.pdf)
- [Memory Layout of C Programs - GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/)
- [Call by Value vs Call by Reference - Stanford CS Education Library](http://cslibrary.stanford.edu/106/)

---

## 문제 해결 (Troubleshooting)

### 일반적인 문제

**문제 1**: Segmentation Fault (세그먼테이션 오류)
- **원인**: 잘못된 주소에 접근
```c
int *ptr;        // 초기화 안 됨!
*ptr = 10;       // 오류! ptr이 가리키는 곳이 없음
```
- **해결**: 포인터를 사용하기 전에 반드시 초기화
```c
int x;
int *ptr = &x;   // 올바름: ptr이 x를 가리킴
*ptr = 10;       // 안전함
```

**문제 2**: 함수에서 주소를 전달했는데도 안 바뀜
- **원인**: 포인터를 받았지만 `*`를 빼먹음
```c
void increment(int *n) {
    n = n + 1;   // 잘못됨! 주소 값을 바꿈
}
```
- **해결**: `*`로 간접 참조
```c
void increment(int *n) {
    *n = *n + 1; // 올바름! 가리키는 값을 바꿈
}
```

**문제 3**: `&`와 `*` 헷갈림
- **기억법**:
  - `&`: "address of" → 주소를 **얻음**
  - `*`: "value at" → 값을 **얻음** (포인터가 가리키는)
  - 선언의 `*`: "이것은 포인터다"

```c
int x = 10;
int *ptr;        // *는 "포인터" 의미

ptr = &x;        // &는 "주소 얻기"
printf("%d", *ptr);  // *는 "값 얻기"
```

**문제 4**: 포인터 타입 불일치
```c
int x = 10;
double *ptr = &x;  // 경고! 타입 불일치
```
- **해결**: 포인터 타입을 변수 타입과 일치시키기
```c
int x = 10;
int *ptr = &x;     // 올바름
```

**문제 5**: 지역 변수 주소 반환
```c
int* create_number(void) {
    int x = 10;
    return &x;  // 위험! x는 함수 끝나면 사라짐
}
```
- **해결**: 전역 변수 사용하거나 동적 할당 (추후 학습)

---

## 심화 개념

### 포인터의 크기

포인터 변수 자체의 크기는 가리키는 타입과 무관하게 동일합니다 (시스템 아키텍처 의존).

```c
#include <stdio.h>

int main(void) {
    printf("int 크기: %zu\n", sizeof(int));
    printf("double 크기: %zu\n", sizeof(double));
    printf("char 크기: %zu\n", sizeof(char));
    
    printf("int* 크기: %zu\n", sizeof(int*));
    printf("double* 크기: %zu\n", sizeof(double*));
    printf("char* 크기: %zu\n", sizeof(char*));
    
    return 0;
}
```

**출력 (64비트 시스템):**
```
int 크기: 4
double 크기: 8
char 크기: 1
int* 크기: 8
double* 크기: 8
char* 크기: 8
```

**이유**: 주소는 메모리 위치를 나타내는 숫자이므로, 가리키는 대상과 무관하게 크기가 같습니다.

### NULL 포인터

초기화되지 않은 포인터는 위험하므로, 사용하지 않는 포인터는 `NULL`로 초기화합니다.

```c
#include <stdio.h>

int main(void) {
    int *ptr = NULL;  // NULL로 초기화
    
    if (ptr == NULL) {
        printf("포인터가 아무것도 가리키지 않음\n");
    }
    
    // 나중에 사용할 때 체크
    if (ptr != NULL) {
        *ptr = 10;  // 안전
    }
    
    return 0;
}
```

**출처**: [ISO C Standard - NULL](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) Section 7.19

---

**수업 준비물 체크리스트**
□ C 컴파일러 환경 (gcc, clang 등)  
□ 코드 에디터 (VS Code, vim 등)  
□ 화이트보드 또는 스케치 도구 (스택 시각화용)  
□ 학생들이 직접 코드를 작성하고 실행할 수 있는 환경  

**과제 제출 마감**: 다음 수업 시작 전까지
