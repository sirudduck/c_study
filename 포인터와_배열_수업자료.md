# 포인터와 배열: 완전 가이드

## 학습 목표
- 배열과 포인터의 관계 이해
- 포인터 산술 연산 마스터
- 함수 매개변수로 배열 전달 시 주의사항 학습

---

## 1. 배열과 포인터 기본

### 1.1 기본 개념

```c
#include <stdio.h>

int main(void) {
    int numbers[5] = {10, 20, 30, 40, 50};
    int *ptr;  // 포인터 변수 선언
    
    // 1단계: 배열 이름은 첫 번째 원소의 주소
    ptr = numbers;  // ptr = &numbers[0]과 동일
    
    printf("=== 배열 인덱스 vs 포인터 접근 ===\n");
    printf("numbers[0] = %d\n", numbers[0]);
    printf("*ptr = %d\n\n", *ptr);
    
    // 2단계: 포인터를 이동하여 다른 원소 접근
    printf("=== 포인터 이동 ===\n");
    printf("현재 *ptr = %d (첫 번째 원소)\n", *ptr);
    
    ptr++;  // 다음 원소로 이동
    printf("ptr++ 후 *ptr = %d (두 번째 원소)\n", *ptr);
    
    ptr++;  // 또 다음 원소로 이동
    printf("ptr++ 후 *ptr = %d (세 번째 원소)\n\n", *ptr);
    
    // 3단계: 포인터로 값 변경
    printf("=== 포인터로 값 변경 ===\n");
    ptr = numbers;  // 다시 처음으로
    
    *ptr = 100;        // numbers[0] = 100
    *(ptr + 2) = 300;  // numbers[2] = 300
    
    ptr += 4;          // 다섯 번째 원소로 이동
    *ptr = 500;        // numbers[4] = 500
    
    // 4단계: 결과 확인
    printf("변경 후 배열:\n");
    for (int i = 0; i < 5; i++) {
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }
    
    return 0;
}
```

**실행 결과:**
```
=== 배열 인덱스 vs 포인터 접근 ===
numbers[0] = 10
*ptr = 10

=== 포인터 이동 ===
현재 *ptr = 10 (첫 번째 원소)
ptr++ 후 *ptr = 20 (두 번째 원소)
ptr++ 후 *ptr = 30 (세 번째 원소)

=== 포인터로 값 변경 ===
변경 후 배열:
numbers[0] = 100
numbers[1] = 20
numbers[2] = 300
numbers[3] = 40
numbers[4] = 500
```

### 1.2 핵심 등식

**중요:** 배열 접근의 두 가지 방법은 완전히 동일합니다.

```
arr[i] ≡ *(arr + i)
```

이는 수학 함수처럼 생각할 수 있습니다:
- `arr[i]`는 i번째 원소를 반환하는 "함수"
- `*(arr + i)`는 같은 결과를 주는 "다른 표기법"

**근거:** ISO/IEC 9899:2018 Section 6.5.2.1 (Array subscripting)

---

## 2. 메모리 구조 이해

### 2.1 메모리 시각화

```
배열 선언: int numbers[5] = {10, 20, 30, 40, 50};

메모리 구조:
┌─────────┬────────┬────────────┐
│  주소   │  값    │  접근 방법 │
├─────────┼────────┼────────────┤
│ 0x1000  │   10   │ numbers[0] │ ← ptr (초기)
├─────────┼────────┼────────────┤
│ 0x1004  │   20   │ numbers[1] │ ← ptr + 1 또는 ptr++ 후
├─────────┼────────┼────────────┤
│ 0x1008  │   30   │ numbers[2] │ ← ptr + 2 또는 ptr++ 두 번 후
├─────────┼────────┼────────────┤
│ 0x100C  │   40   │ numbers[3] │ ← ptr + 3
├─────────┼────────┼────────────┤
│ 0x1010  │   50   │ numbers[4] │ ← ptr + 4
└─────────┴────────┴────────────┘

포인터 산술:
• ptr++     → 주소가 4바이트 증가 (int 크기만큼)
• ptr + 2   → 주소가 8바이트 증가 (2 × sizeof(int))
• *(ptr+i)  → numbers[i]와 동일
```

### 2.2 주소 간격의 의미

```c
int arr[3];
// int는 4바이트이므로
// arr[0]과 arr[1]의 주소 차이 = 4바이트
// arr[1]과 arr[2]의 주소 차이 = 4바이트
```

---

## 3. 고급 포인터 산술

### 3.1 다양한 포인터 연산

```c
#include <stdio.h>

int main(void) {
    int arr[7] = {100, 200, 300, 400, 500, 600, 700};
    int *start, *end, *current;
    
    // === 1. 역방향 순회 ===
    printf("=== 역방향 순회 ===\n");
    end = arr + 6;  // 마지막 원소를 가리킴
    
    for (current = end; current >= arr; current--) {
        printf("%d ", *current);
    }
    printf("\n\n");
    
    // === 2. 포인터 간 거리 계산 ===
    printf("=== 포인터 간 거리 ===\n");
    start = arr;
    end = arr + 6;
    
    printf("start가 가리키는 값: %d\n", *start);
    printf("end가 가리키는 값: %d\n", *end);
    printf("두 포인터 사이의 원소 개수: %ld\n\n", end - start);
    
    // === 3. 중간 지점부터 양방향 수정 ===
    printf("=== 중간 지점부터 양방향 수정 ===\n");
    current = arr + 3;  // 중간(인덱스 3)부터 시작
    
    *current = 999;        // arr[3] 수정
    *(current - 1) = 888;  // arr[2] 수정 (왼쪽으로)
    *(current + 2) = 777;  // arr[5] 수정 (오른쪽으로)
    
    printf("수정 후 배열: ");
    for (int i = 0; i < 7; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
    
    // === 4. 포인터로 부분 배열 처리 ===
    printf("=== 부분 배열 합계 (인덱스 2~5) ===\n");
    int sum = 0;
    start = arr + 2;  // 인덱스 2부터
    end = arr + 6;    // 인덱스 5까지 (6 미포함)
    
    for (current = start; current < end; current++) {
        sum += *current;
        printf("더하는 값: %d (누적: %d)\n", *current, sum);
    }
    printf("합계: %d\n\n", sum);
    
    // === 5. 포인터 비교 ===
    printf("=== 포인터 위치 비교 ===\n");
    int *p1 = arr + 2;
    int *p2 = arr + 5;
    
    if (p1 < p2) {
        printf("p1이 p2보다 배열 앞쪽에 위치\n");
        printf("p1과 p2 사이 거리: %ld 칸\n", p2 - p1);
    }
    
    return 0;
}
```

**실행 결과:**
```
=== 역방향 순회 ===
700 600 500 400 300 200 100 

=== 포인터 간 거리 ===
start가 가리키는 값: 100
end가 가리키는 값: 700
두 포인터 사이의 원소 개수: 6

=== 중간 지점부터 양방향 수정 ===
수정 후 배열: 100 200 888 999 500 777 700 

=== 부분 배열 합계 (인덱스 2~5) ===
더하는 값: 888 (누적: 888)
더하는 값: 999 (누적: 1887)
더하는 값: 500 (누적: 2387)
더하는 값: 777 (누적: 3164)
합계: 3164

=== 포인터 위치 비교 ===
p1이 p2보다 배열 앞쪽에 위치
p1과 p2 사이 거리: 3 칸
```

### 3.2 포인터 연산 정리

| 연산 | 의미 | 예시 | 결과 |
|------|------|------|------|
| `ptr++` | 다음 원소로 이동 | `ptr = ptr + 1` | 주소 +4바이트 |
| `ptr--` | 이전 원소로 이동 | `ptr = ptr - 1` | 주소 -4바이트 |
| `ptr + n` | n칸 앞으로 이동 | `arr + 3` | 주소 +12바이트 |
| `ptr - n` | n칸 뒤로 이동 | `end - 2` | 주소 -8바이트 |
| `ptr2 - ptr1` | 포인터 간 거리 | `(arr+6) - arr` | `6` (원소 개수) |
| `ptr1 < ptr2` | 포인터 위치 비교 | `p1 < p2` | 배열 순서 확인 |

**근거:** 
- ISO/IEC 9899:2018 Section 6.5.6 (Additive operators)
- ISO/IEC 9899:2018 Section 6.5.8 (Relational operators)

---

## 4. 함수 매개변수와 배열 Decay

### 4.1 문제 상황

```c
#include <stdio.h>

// 잘못된 접근: 매개변수에서 sizeof 사용
void wrong_print_array(int arr[]) {
    // arr는 사실 int* 포인터입니다!
    int size = sizeof(arr) / sizeof(arr[0]);
    
    printf("함수 내부에서 계산한 크기: %d\n", size);
    printf("sizeof(arr) = %zu 바이트\n", sizeof(arr));
    printf("sizeof(arr[0]) = %zu 바이트\n", sizeof(arr[0]));
    printf("계산: %zu / %zu = %d (잘못됨!)\n\n", 
           sizeof(arr), sizeof(arr[0]), size);
}

// 올바른 접근: 크기를 별도 매개변수로 전달
void correct_print_array(int arr[], int size) {
    printf("올바른 방법으로 출력:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
}

int main(void) {
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // main 함수에서는 sizeof가 제대로 작동
    int actual_size = sizeof(numbers) / sizeof(numbers[0]);
    
    printf("=== main 함수에서 ===\n");
    printf("sizeof(numbers) = %zu 바이트\n", sizeof(numbers));
    printf("sizeof(numbers[0]) = %zu 바이트\n", sizeof(numbers[0]));
    printf("실제 배열 크기: %d\n\n", actual_size);
    
    printf("=== 함수에 전달 후 ===\n");
    wrong_print_array(numbers);
    
    correct_print_array(numbers, actual_size);
    
    return 0;
}
```

**실행 결과 (64비트 시스템):**
```
=== main 함수에서 ===
sizeof(numbers) = 20 바이트
sizeof(numbers[0]) = 4 바이트
실제 배열 크기: 5

=== 함수에 전달 후 ===
함수 내부에서 계산한 크기: 2
sizeof(arr) = 8 바이트
sizeof(arr[0]) = 4 바이트
계산: 8 / 4 = 2 (잘못됨!)

올바른 방법으로 출력:
10 20 30 40 50
```

### 4.2 메모리 구조 비교

```
main 함수에서:
┌──────────────────────────────────────┐
│ int numbers[5]                       │
│ [10] [20] [30] [40] [50]            │
│  ↑                                   │
│  └─ sizeof(numbers) = 20바이트      │
│     (5개 × 4바이트)                  │
└──────────────────────────────────────┘

함수 호출: wrong_print_array(numbers)
                    ↓
         배열이 포인터로 decay!

함수 내부에서:
┌──────────────────────────────────────┐
│ int *arr  (포인터 변수)              │
│ [주소값: 0x1000]                     │
│  ↑                                   │
│  └─ sizeof(arr) = 8바이트           │
│     (64비트 시스템에서 포인터 크기) │
└──────────────────────────────────────┘
     │
     └──→ [10] [20] [30] [40] [50]
          실제 배열은 여기 있음
```

### 4.3 배열 매개변수의 세 가지 선언 방식

```c
#include <stdio.h>

void demonstrate_decay(int arr[], int size) {
    printf("=== 배열 매개변수의 실체 ===\n");
    printf("다음 세 가지 선언은 모두 동일합니다:\n");
    printf("  void func(int arr[]);\n");
    printf("  void func(int arr[5]);\n");
    printf("  void func(int *arr);\n");
    printf("→ 모두 'int *arr'로 컴파일됨\n\n");
    
    printf("매개변수 arr의 타입 크기: %zu 바이트 (포인터)\n", sizeof(arr));
    printf("전달받은 실제 배열 크기: %d 개\n\n", size);
}

// 다양한 선언 방식 비교
void method1(int arr[]) { }      // 가장 일반적
void method2(int arr[10]) { }    // 크기는 무시됨
void method3(int *arr) { }       // 명시적 포인터

int main(void) {
    int data[5] = {1, 2, 3, 4, 5};
    
    printf("=== 지역 배열 vs 매개변수 배열 ===\n");
    printf("지역 배열:\n");
    printf("  sizeof(data) = %zu 바이트\n", sizeof(data));
    printf("  배열 원소 개수 = %zu\n\n", sizeof(data) / sizeof(data[0]));
    
    demonstrate_decay(data, 5);
    
    // 모든 함수 호출 방식이 동일하게 작동
    method1(data);
    method2(data);
    method3(data);
    
    return 0;
}
```

**실행 결과:**
```
=== 지역 배열 vs 매개변수 배열 ===
지역 배열:
  sizeof(data) = 20 바이트
  배열 원소 개수 = 5

=== 배열 매개변수의 실체 ===
다음 세 가지 선언은 모두 동일합니다:
  void func(int arr[]);
  void func(int arr[5]);
  void func(int *arr);
→ 모두 'int *arr'로 컴파일됨

매개변수 arr의 타입 크기: 8 바이트 (포인터)
전달받은 실제 배열 크기: 5 개
```

---

## 5. 실전 예제

### 5.1 배열 처리 함수 모음

```c
#include <stdio.h>

// 배열 합계 계산
int sum_array(int arr[], int size) {
    int total = 0;
    for (int i = 0; i < size; i++) {
        total += arr[i];
    }
    return total;
}

// 배열 최댓값 찾기
int find_max(int arr[], int size) {
    if (size <= 0) return 0;  // 안전장치
    
    int max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// 배열 내용 2배로 만들기
void double_values(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

// 배열 출력
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(void) {
    int scores[6] = {85, 92, 78, 95, 88, 91};
    int size = sizeof(scores) / sizeof(scores[0]);
    
    printf("원본 배열: ");
    print_array(scores, size);
    
    printf("합계: %d\n", sum_array(scores, size));
    printf("최댓값: %d\n", find_max(scores, size));
    
    double_values(scores, size);
    printf("2배 후 배열: ");
    print_array(scores, size);
    
    return 0;
}
```

**실행 결과:**
```
원본 배열: 85 92 78 95 88 91
합계: 529
최댓값: 95
2배 후 배열: 170 184 156 190 176 182
```

---

## 6. 핵심 개념 정리

### 6.1 sizeof() 동작 비교

| 상황 | sizeof() 결과 | 이유 |
|------|---------------|------|
| `int arr[5]` (지역 변수) | 20 바이트 | 실제 배열 전체 크기 (5 × 4) |
| `int arr[]` (함수 매개변수) | 8 바이트 (64bit) | 포인터로 decay되어 포인터 크기 반환 |
| `int *ptr` (포인터 변수) | 8 바이트 (64bit) | 포인터 자체의 크기 |

### 6.2 배열 크기를 함께 전달해야 하는 이유

**문제:**
1. 배열이 함수로 전달되면 **포인터로 decay**됨
2. 포인터는 **첫 번째 원소의 주소만** 가지고 있음
3. 배열의 **끝이 어디인지 알 수 없음**
4. `sizeof()`로 **크기를 계산할 수 없음**

**해결책:**
```c
// ✅ 올바른 방법
void process_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        // 처리
    }
}

int main(void) {
    int data[10];
    int size = sizeof(data) / sizeof(data[0]);  // main에서 계산
    process_array(data, size);                  // 크기와 함께 전달
}
```

```c
// ❌ 잘못된 방법
void process_array(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // 잘못된 크기!
    for (int i = 0; i < size; i++) {
        // 처리
    }
}
```

### 6.3 C 표준 근거

**ISO/IEC 9899:2018 Section 6.7.6.3 paragraph 7:**
> "A declaration of a parameter as 'array of type' shall be adjusted to 'qualified pointer to type'"

배열 매개변수는 컴파일러에 의해 자동으로 포인터로 조정됩니다.

---

## 7. 연습 문제

### 문제 1: 배열 뒤집기
포인터를 사용하여 배열의 순서를 뒤집는 함수를 작성하세요.
```c
void reverse_array(int arr[], int size);
```

### 문제 2: 배열에서 특정 값 찾기
포인터를 사용하여 배열에서 특정 값을 찾고, 그 값의 인덱스를 반환하는 함수를 작성하세요. 값이 없으면 -1을 반환합니다.
```c
int find_value(int arr[], int size, int target);
```

### 문제 3: 두 배열 합치기
두 배열을 받아서 세 번째 배열에 순서대로 복사하는 함수를 작성하세요.
```c
void merge_arrays(int arr1[], int size1, int arr2[], int size2, int result[]);
```

---

## 8. 요약

### 핵심 포인트
1. **배열과 포인터**: `arr[i]` ≡ `*(arr + i)`
2. **포인터 산술**: `ptr++`, `ptr + n`, `ptr2 - ptr1` 모두 타입 크기 고려
3. **Array Decay**: 함수 매개변수로 전달 시 배열 → 포인터로 변환
4. **크기 전달 필수**: 함수 내에서 `sizeof()`로 배열 크기 계산 불가
5. **안전한 코딩**: 항상 배열 크기를 함께 전달하여 경계 검사

### 실무 규칙
- ✅ 배열 크기는 `main()`에서 계산하여 전달
- ✅ 함수 매개변수는 `int arr[], int size` 형태로 선언
- ✅ 포인터 산술 사용 시 배열 경계 확인
- ❌ 함수 내에서 `sizeof(arr)`로 크기 계산 금지
- ❌ 배열 경계를 넘어서는 포인터 접근 금지

---

**참고 자료:**
- ISO/IEC 9899:2018 (C18 Standard)
- Kernighan & Ritchie, "The C Programming Language"
- C Reference: https://en.cppreference.com/w/c
