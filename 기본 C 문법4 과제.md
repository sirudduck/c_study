# C Programming Session 5: 과제

**제출 마감**: 다음 수업 시작 전까지  
**제출 방법**: 각 과제를 별도의 `.c` 파일로 작성하여 제출

---

## 과제 1: 최댓값과 최솟값 찾기 ⭐⭐

**학습 목표:**
- 포인터를 사용하여 여러 값 반환하기
- 배열 순회 및 비교 연산

**요구사항:**
- 배열의 최댓값과 최솟값을 찾는 함수 작성
- 하나의 함수로 두 값을 동시에 반환 (포인터 사용)
- `find_min_max(int arr[], int size, int *min, int *max)` 형태

**코드 템플릿:**
```c
#include <stdio.h>

void find_min_max(int arr[], int size, int *min, int *max) {
    // 여기에 코드 작성
    // 힌트:
    // 1. min과 max를 첫 번째 원소로 초기화
    // 2. 배열을 순회하며 최솟값, 최댓값 갱신
}

int main(void) {
    int numbers[] = {15, 3, 22, 8, 19, 2, 11};
    int size = 7;
    int min, max;
    
    find_min_max(numbers, size, &min, &max);
    
    printf("최솟값: %d\n", min);
    printf("최댓값: %d\n", max);
    
    return 0;
}
```

**목표 출력:**
```
최솟값: 2
최댓값: 22
```

**테스트 케이스:**
다음 배열들로도 테스트해보세요:
```c
int test1[] = {5};                    // 크기 1
int test2[] = {-5, -10, -3, -8};      // 모두 음수
int test3[] = {100, 100, 100};        // 모두 같은 값
```

---

## 과제 2: 배열 순환 시프트 ⭐⭐⭐

**학습 목표:**
- swap 함수 활용
- 배열 조작 연습
- 반복문과 포인터 결합

**요구사항:**
- 배열의 모든 원소를 왼쪽으로 한 칸씩 이동
- 첫 번째 원소는 마지막으로 이동
- 포인터와 swap 함수를 활용

**동작 예시:**
```
입력: [1, 2, 3, 4, 5]
출력: [2, 3, 4, 5, 1]

입력: [10, 20, 30]
출력: [20, 30, 10]
```

**코드 템플릿:**
```c
#include <stdio.h>

void swap(int *a, int *b) {
    // swap 함수 구현
}

void rotate_left(int arr[], int size) {
    // 여기에 코드 작성
    // 힌트: arr[0]과 arr[1] swap, arr[1]과 arr[2] swap, ...
    // for 반복문 사용
}

void print_array(int arr[], int size) {
    printf("[");
    for (int i = 0; i < size; i++) {
        printf("%d", arr[i]);
        if (i < size - 1) printf(", ");
    }
    printf("]\n");
}

int main(void) {
    int arr[] = {1, 2, 3, 4, 5};
    int size = 5;
    
    printf("원본: ");
    print_array(arr, size);
    
    rotate_left(arr, size);
    
    printf("회전 후: ");
    print_array(arr, size);
    
    return 0;
}
```

**도전 과제 (선택):**
- `rotate_right` 함수도 만들어보세요 (오른쪽으로 회전)
- n칸 회전하는 `rotate_left_n(int arr[], int size, int n)` 함수도 만들어보세요

---

## 과제 3: 나누기 함수 (몫과 나머지) ⭐⭐⭐

**학습 목표:**
- 포인터로 여러 값 반환
- 오류 처리 (0으로 나누기)
- 함수 반환값 활용

**요구사항:**
- 두 정수의 나눗셈 결과를 계산하는 함수
- 몫과 나머지를 동시에 반환 (포인터 사용)
- 0으로 나누는 경우 처리

**함수 시그니처:**
```c
int divide(int dividend, int divisor, int *quotient, int *remainder);
// 반환값: 성공 시 0, 실패 시 -1
```

**코드 템플릿:**
```c
#include <stdio.h>

int divide(int dividend, int divisor, int *quotient, int *remainder) {
    // 여기에 코드 작성
    // 1. divisor가 0이면 -1 반환
    // 2. 그렇지 않으면:
    //    - *quotient에 몫 저장
    //    - *remainder에 나머지 저장
    //    - 0 반환
}

int main(void) {
    int a = 17, b = 5;
    int quotient, remainder;
    
    if (divide(a, b, &quotient, &remainder) == 0) {
        printf("%d ÷ %d = %d ... %d\n", a, b, quotient, remainder);
    } else {
        printf("오류: 0으로 나눌 수 없습니다.\n");
    }
    
    // 0으로 나누기 테스트
    if (divide(10, 0, &quotient, &remainder) == -1) {
        printf("0으로 나누기 오류 감지됨\n");
    }
    
    return 0;
}
```

**목표 출력:**
```
17 ÷ 5 = 3 ... 2
0으로 나누기 오류 감지됨
```

**테스트 케이스:**
```c
divide(20, 3, &q, &r);   // 6 ... 2
divide(15, 5, &q, &r);   // 3 ... 0
divide(-17, 5, &q, &r);  // -3 ... -2 (또는 -4 ... 3, 구현 방식에 따라)
```

**참고**: C의 `/`와 `%` 연산자를 사용할 수 있습니다.

---

## 과제 4: 버블 정렬 구현 ⭐⭐⭐⭐

**학습 목표:**
- 정렬 알고리즘 이해
- 중첩 반복문 사용
- swap 함수 활용

**요구사항:**
- 배열을 오름차순으로 정렬하는 버블 정렬 구현
- swap 함수 활용
- 정렬 과정을 출력 (선택)

**버블 정렬 알고리즘:**

버블 정렬은 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다.

```
예시: [5, 2, 8, 1]

1회전:
[5, 2, 8, 1] → [2, 5, 8, 1] (5와 2 비교, swap)
[2, 5, 8, 1] → [2, 5, 8, 1] (5와 8 비교, 그대로)
[2, 5, 8, 1] → [2, 5, 1, 8] (8과 1 비교, swap)

2회전:
[2, 5, 1, 8] → [2, 5, 1, 8] (2와 5 비교, 그대로)
[2, 5, 1, 8] → [2, 1, 5, 8] (5와 1 비교, swap)
[2, 1, 5, 8] → [2, 1, 5, 8] (5와 8 비교, 그대로)

3회전:
[2, 1, 5, 8] → [1, 2, 5, 8] (2와 1 비교, swap)
[1, 2, 5, 8] → [1, 2, 5, 8] (2와 5 비교, 그대로)
[1, 2, 5, 8] → [1, 2, 5, 8] (5와 8 비교, 그대로)

정렬 완료: [1, 2, 5, 8]
```

**코드 템플릿:**
```c
#include <stdio.h>

void swap(int *a, int *b) {
    // swap 함수 구현
}

void bubble_sort(int arr[], int size) {
    // 여기에 버블 정렬 구현
    // 힌트:
    // for (int i = 0; i < size - 1; i++) {
    //     for (int j = 0; j < size - 1 - i; j++) {
    //         if (arr[j] > arr[j + 1]) {
    //             swap(&arr[j], &arr[j + 1]);
    //         }
    //     }
    // }
}

void print_array(int arr[], int size) {
    printf("[");
    for (int i = 0; i < size; i++) {
        printf("%d", arr[i]);
        if (i < size - 1) printf(", ");
    }
    printf("]\n");
}

int main(void) {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int size = 7;
    
    printf("정렬 전: ");
    print_array(arr, size);
    
    bubble_sort(arr, size);
    
    printf("정렬 후: ");
    print_array(arr, size);
    
    return 0;
}
```

**목표 출력:**
```
정렬 전: [64, 34, 25, 12, 22, 11, 90]
정렬 후: [11, 12, 22, 25, 34, 64, 90]
```

**도전 과제 (선택):**
1. 정렬 과정을 단계별로 출력하는 기능 추가
2. 최적화: 한 회전에서 swap이 한 번도 일어나지 않으면 정렬 완료 (조기 종료)
3. 내림차순 정렬도 구현해보기

**예시 (정렬 과정 출력):**
```c
void bubble_sort_verbose(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        printf("회전 %d: ", i + 1);
        for (int j = 0; j < size - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
        print_array(arr, size);
    }
}
```

---

## 제출 시 주의사항

### 파일명 규칙
```
과제1: homework5_1.c
과제2: homework5_2.c
과제3: homework5_3.c
과제4: homework5_4.c
```

### 코드 작성 규칙
1. **주석 작성**: 각 함수 위에 간단한 설명 주석 추가
   ```c
   // 두 정수를 교환하는 함수
   void swap(int *a, int *b) {
       ...
   }
   ```

2. **변수명**: 의미 있는 이름 사용
   ```c
   // Good
   int max_value, min_value;
   
   // Bad
   int a, b;
   ```

3. **들여쓰기**: 일관된 들여쓰기 (스페이스 4칸 또는 탭)

4. **컴파일 테스트**: 제출 전 반드시 컴파일 및 실행 확인
   ```bash
   gcc homework5_1.c -o homework5_1
   ./homework5_1
   ```

### 채점 기준
- **동작 정확성** (40%): 요구사항대로 작동하는가?
- **코드 품질** (30%): 읽기 쉽고 이해하기 쉬운가?
- **포인터 활용** (20%): 포인터를 올바르게 사용했는가?
- **오류 처리** (10%): 예외 상황을 처리하는가?

---

## 도움말

### 자주하는 실수

**1. 포인터 초기화 안 함**
```c
// Wrong
int *ptr;
*ptr = 10;  // 세그먼테이션 오류!

// Correct
int x;
int *ptr = &x;
*ptr = 10;  // 안전함
```

**2. & 빼먹음**
```c
// Wrong
swap(a, b);  // 값이 안 바뀜

// Correct
swap(&a, &b);  // 주소 전달
```

**3. * 빼먹음**
```c
// Wrong (함수 안에서)
void increment(int *n) {
    n = n + 1;  // 주소를 바꿈 (의미 없음)
}

// Correct
void increment(int *n) {
    *n = *n + 1;  // 값을 바꿈
}
```

### 디버깅 팁

**값 확인하기:**
```c
printf("DEBUG: x = %d, &x = %p\n", x, &x);
printf("DEBUG: ptr = %p, *ptr = %d\n", ptr, *ptr);
```

**함수 호출 추적:**
```c
void swap(int *a, int *b) {
    printf("swap 호출: *a = %d, *b = %d\n", *a, *b);
    // ... swap 로직 ...
    printf("swap 종료: *a = %d, *b = %d\n", *a, *b);
}
```

---

## 참고 자료

- [ISO C Standard - Pointers](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)
- Kernighan & Ritchie, "The C Programming Language", Chapter 5
- [Stanford CS Education Library - Pointers](http://cslibrary.stanford.edu/106/)

---

**질문이 있으면 수업 시간에 또는 이메일로 문의하세요!**

**행운을 빕니다! 🚀**
