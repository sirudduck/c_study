# Session 7: 2차원 배열과 함수 포인터

---

## 학습 목표

- 2차원 배열의 선언, 초기화, 접근 방법을 이해한다.
- 2차원 배열이 메모리(스택)에 어떻게 배치되는지 이해한다.
- 포인터 배열과 배열 포인터의 차이를 구별할 수 있다.
- 배열 포인터가 왜 다차원 배열을 위해 존재하는지 이해한다.
- 2차원 배열을 함수에 전달할 때 배열 포인터로 decay되는 과정을 이해한다.
- 함수 포인터의 개념과 기본 사용법을 익힌다.

---

## 1. 2차원 배열 (Two-Dimensional Arrays)

### 1.1 선언과 초기화

2차원 배열은 **행(row) × 열(column)** 구조로 선언합니다.

```c
// 선언
int matrix[3][4];  // 3행 4열

// 선언과 동시에 초기화
int matrix[3][4] = {
    {1,  2,  3,  4},   // 0번 행
    {5,  6,  7,  8},   // 1번 행
    {9, 10, 11, 12}    // 2번 행
};
```

전기전자공학에서 자주 접하는 행렬(matrix)과 구조가 동일합니다.

$$
A = \begin{pmatrix} 1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8 \\ 9 & 10 & 11 & 12 \end{pmatrix}
$$

`matrix[i][j]`는 $A_{ij}$에 대응합니다.

---

### 1.2 메모리 배치 — 스택에서 실제로 어떻게 놓이는가?

#### 먼저: 1차원 배열의 스택 배치

2차원을 이해하기 전에 1차원부터 명확히 짚겠습니다.

```c
int arr[5] = {10, 20, 30, 40, 50};
```

스택에는 이렇게 놓입니다 (`int` = 4바이트 가정):

```
스택 (낮은 주소 → 높은 주소)

주소:    0x1000   0x1004   0x1008   0x100C   0x1010
값:        10       20       30       40       50
인덱스:  arr[0]  arr[1]  arr[2]  arr[3]  arr[4]
```

`arr[i]`의 주소 = `시작 주소 + i × sizeof(int)`

```
arr[0] → 0x1000 + 0 × 4 = 0x1000  → 값: 10 ✓
arr[2] → 0x1000 + 2 × 4 = 0x1008  → 값: 30 ✓
```

#### 2차원 배열의 스택 배치 — "행을 이어 붙인 것"

C에서 2차원 배열은 **"1차원 배열을 행 개수만큼 이어 붙인 것"** 입니다.
화면에서는 2차원으로 보이지만, 메모리는 여전히 **한 줄짜리 연속 공간**입니다.

```c
int matrix[3][4] = {
    {1,  2,  3,  4},   // 0번 행
    {5,  6,  7,  8},   // 1번 행
    {9, 10, 11, 12}    // 2번 행
};
```

스택의 실제 모습:

```
주소:  0x1000 0x1004 0x1008 0x100C | 0x1010 0x1014 0x1018 0x101C | 0x1020 0x1024 0x1028 0x102C
값:       1      2      3      4   |    5      6      7      8   |    9     10     11     12
표기: [0][0] [0][1] [0][2] [0][3]  [1][0] [1][1] [1][2] [1][3]  [2][0] [2][1] [2][2] [2][3]
      ←────────── 0번 행 ─────────→ ←────────── 1번 행 ─────────→ ←────────── 2번 행 ─────────→
```

**핵심:** 2차원처럼 보이지만 메모리는 1차원 직선입니다.

#### `matrix[i][j]`의 주소 계산 공식

```
주소 = 시작 주소 + (i × 열_개수 + j) × sizeof(int)
```

실제로 계산해 봅시다:

```
matrix[0][0] → 0x1000 + (0 × 4 + 0) × 4 = 0x1000 + 0  = 0x1000  → 값:  1 ✓
matrix[0][3] → 0x1000 + (0 × 4 + 3) × 4 = 0x1000 + 12 = 0x100C  → 값:  4 ✓
matrix[1][0] → 0x1000 + (1 × 4 + 0) × 4 = 0x1000 + 16 = 0x1010  → 값:  5 ✓
matrix[1][2] → 0x1000 + (1 × 4 + 2) × 4 = 0x1000 + 24 = 0x1018  → 값:  7 ✓
matrix[2][3] → 0x1000 + (2 × 4 + 3) × 4 = 0x1000 + 44 = 0x102C  → 값: 12 ✓
```

코드로 직접 확인:

```c
#include <stdio.h>

int main(void) {
    int matrix[3][4] = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12}
    };

    printf("시작 주소:         %p\n", (void *)matrix);
    printf("matrix[0][0] 주소: %p, 값: %d\n", (void *)&matrix[0][0], matrix[0][0]);
    printf("matrix[1][0] 주소: %p, 값: %d\n", (void *)&matrix[1][0], matrix[1][0]);
    printf("matrix[2][3] 주소: %p, 값: %d\n", (void *)&matrix[2][3], matrix[2][3]);

    return 0;
}
```

실행하면 주소 간 차이가 위 계산과 정확히 일치합니다. 직접 확인해보세요.

---

### 1.3 2차원 배열 순회

```c
#include <stdio.h>

int main(void) {
    int matrix[3][4] = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12}
    };

    int rows = 3;
    int cols = 4;

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%4d", matrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

출력:
```
   1   2   3   4
   5   6   7   8
   9  10  11  12
```

---

## 2. 포인터 배열과 배열 포인터

2차원 배열을 함수에 넘기기 전에, 먼저 이 두 개념을 구분해야 합니다.
선언이 비슷해서 헷갈리기 쉽지만, 동작이 전혀 다릅니다.

### 2.1 선언 읽는 법

```c
int *p[4];    // 포인터 배열 (Array of Pointers)
int (*p)[4];  // 배열 포인터 (Pointer to Array)
```

C 선언 읽기 규칙 — **"괄호가 있으면 포인터가 먼저":**

```
int *p[4]
  → p는 배열[4], 원소 타입은 int*
  → "int 포인터 4개를 담는 배열"  →  포인터 배열

int (*p)[4]
  → 괄호로 p가 먼저 *와 결합 → p는 포인터
  → 그 포인터가 가리키는 것은 int[4]
  → "int 4개짜리 배열을 가리키는 포인터"  →  배열 포인터
```

**한 줄 요약:**
- 괄호 없음 → 배열이 먼저 → **포인터 배열**
- 괄호 있음  → 포인터가 먼저 → **배열 포인터**

---

### 2.2 포인터 배열 (Array of Pointers)

포인터를 원소로 갖는 배열입니다.

```c
int a = 1, b = 2, c = 3;
int *ptrs[3] = {&a, &b, &c};

printf("%d\n", *ptrs[0]);  // 1
printf("%d\n", *ptrs[1]);  // 2
```

문자열 목록에서 자주 등장합니다:

```c
const char *days[7] = {
    "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"
};
printf("%s\n", days[2]);  // Wed
```

`main` 함수의 `char *argv[]`가 바로 포인터 배열입니다.

---

### 2.3 배열 포인터 (Pointer to Array) — 왜 존재하는가?

배열이 포인터로 decay될 때 그냥 `int *`로 받으면 되지 않을까? 라는 의문이 자연스럽게 생깁니다. 비교해 보겠습니다.

#### `int *p`로 받는 경우 — "원소 단위" 이동

```c
int matrix[3][4] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} };

int *p = matrix;  // 첫 번째 원소(int 하나)를 가리킴

// p + 1은 int 하나(4바이트)만큼 이동
p + 0  →  &matrix[0][0]  (값: 1)
p + 1  →  &matrix[0][1]  (값: 2)
p + 4  →  &matrix[1][0]  (값: 5)   // 1행으로 가려면 +4를 직접 계산해야 함
```

열이 4개인지 컴파일러가 모르기 때문에 `p + 1`은 그냥 원소 하나만 이동합니다.

#### `int (*p)[4]`로 받는 경우 — "행 단위" 이동

```c
int (*p)[4] = matrix;  // 첫 번째 행(int 4개짜리 배열)을 가리킴

// p + 1은 int[4] 하나(16바이트)만큼 이동
p + 0  →  matrix[0]  (0번 행 전체)
p + 1  →  matrix[1]  (1번 행 전체, 16바이트 이동)
p + 2  →  matrix[2]  (2번 행 전체, 32바이트 이동)
```

`int[4]`라는 타입이 "한 행이 4개"라는 정보를 담고 있어서, `p + 1`이 자동으로 다음 행을 가리킵니다.

#### 이동 거리 비교

```
포인터 타입     가리키는 단위     p + 1 이동 거리
int *           int 하나          4바이트
int (*)[4]      int[4] 하나       16바이트
```

포인터 연산에서 `p + 1`은 항상 **"가리키는 타입 하나만큼"** 이동합니다. 타입이 다르면 이동 거리가 달라집니다.

#### 실질적 차이 — 함수에서 `[i][j]` 문법 사용 가능 여부

```c
// int * 로 받으면 — [i][j] 문법 사용 불가, 오프셋을 직접 계산해야 함
void print(int *mat, int rows, int cols) {
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            printf("%4d", mat[i * cols + j]);  // 직접 계산
}

// int (*p)[4] 로 받으면 — [i][j] 문법 그대로 사용 가능
void print(int (*mat)[4], int rows) {
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < 4; j++)
            printf("%4d", mat[i][j]);           // 컴파일러가 알아서 계산
}
```

**결론: 배열 포인터는 사실상 다차원 배열을 위해 존재하는 개념입니다.**
`[i][j]` 문법과 행 단위 포인터 이동을 가능하게 하기 위해 열 크기를 타입에 포함시킨 것입니다.
2차원 배열을 쓰지 않는 코드에서는 배열 포인터를 직접 선언할 일이 없습니다.

---

### 2.4 한눈에 비교

| 구분 | 선언 | 의미 | 주요 사용처 |
|------|------|------|------------|
| 포인터 배열 | `int *p[4]` | int* 를 4개 담는 배열 | `argv`, 문자열 목록 |
| 배열 포인터 | `int (*p)[4]` | int 4개짜리 배열을 가리키는 포인터 | 2차원 배열 함수 전달 |

---

## 3. 함수에 2차원 배열 전달

앞서 배열 포인터를 이해했으니, 이제 함수 전달 과정이 자연스럽게 이해됩니다.

### 3.1 decay — 2차원 배열이 함수에 넘겨질 때

1차원 배열을 함수에 넘기면 첫 번째 원소의 포인터(`int *`)로 decay됩니다.

```
int arr[5]      →  (함수에 넘기면)  →  int *
```

2차원 배열을 함수에 넘기면 첫 번째 **행**의 포인터, 즉 배열 포인터로 decay됩니다.

```
int matrix[3][4]  →  (함수에 넘기면)  →  int (*)[4]
```

---

### 3.2 함수 선언 방식

따라서 함수 매개변수는 두 가지 방식으로 쓸 수 있으며, **둘은 완전히 동일합니다:**

```c
// 방식 1: 배열 문법 (더 자주 씀)
void print_matrix(int mat[][4], int rows);

// 방식 2: 배열 포인터 문법 (컴파일러가 실제로 보는 것)
void print_matrix(int (*mat)[4], int rows);
```

---

### 3.3 왜 열 크기가 필수이고, 행 크기는 생략 가능한가?

함수 안에서 `mat[i][j]`의 주소 계산 공식:

```
주소 = 시작 주소 + (i × 열_개수 + j) × sizeof(int)
```

공식에 **열 개수**는 들어가지만, **행 개수**는 없습니다. 그래서 열 크기는 타입에 반드시 포함되어야 하고, 행 크기는 없어도 됩니다.

```
열이 4인 경우: matrix[1][0] = 시작 + (1×4 + 0)×4 = 시작 + 16바이트
열이 6인 경우: matrix[1][0] = 시작 + (1×6 + 0)×4 = 시작 + 24바이트
```

열 크기가 다르면 같은 `[1][0]`이라도 전혀 다른 주소를 가리킵니다.

> **비유:** 영화관에서 "3열 2번" 좌석을 찾으려면 한 열에 몇 자리인지 반드시 알아야 합니다. 총 몇 줄인지(행 크기)는 몰라도 됩니다.

---

### 3.4 올바른 함수 선언 정리

```c
// ✅ 올바름: 열 크기 명시
void print_matrix(int mat[][4], int rows);

// ✅ 올바름: 동일한 의미의 배열 포인터 문법
void print_matrix(int (*mat)[4], int rows);

// ❌ 컴파일 오류: 열 크기 없음 — 주소 계산 불가
void print_matrix(int mat[][], int rows);

// ❌ 타입 오류: int**는 2차원 배열과 구조가 다름
void print_matrix(int **mat, int rows);
```

> **`int **mat`은 왜 안 되나?**
> `int **`는 "int를 가리키는 포인터를 가리키는 포인터"로, 연속 메모리 블록인 2차원 배열과 구조가 완전히 다릅니다. 컴파일러가 같다고 허용하면 잘못된 주소를 계산해 프로그램이 오작동합니다.

---

### 3.5 실습: 행렬 덧셈

```c
#include <stdio.h>

#define ROWS 3
#define COLS 3

void matrix_add(int a[][COLS], int b[][COLS], int result[][COLS], int rows) {
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < COLS; j++)
            result[i][j] = a[i][j] + b[i][j];
}

void print_matrix(int mat[][COLS], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < COLS; j++)
            printf("%4d", mat[i][j]);
        printf("\n");
    }
}

int main(void) {
    int A[ROWS][COLS] = {{1,2,3},{4,5,6},{7,8,9}};
    int B[ROWS][COLS] = {{9,8,7},{6,5,4},{3,2,1}};
    int C[ROWS][COLS] = {0};

    matrix_add(A, B, C, ROWS);
    print_matrix(C, ROWS);

    return 0;
}
```

출력:
```
  10  10  10
  10  10  10
  10  10  10
```

---

## 4. 함수 포인터 (Function Pointers)

### 4.1 함수 포인터란?

C에서 **함수도 메모리 주소를 가집니다.** 함수 포인터는 그 주소를 저장하는 변수입니다.

```c
int add(int a, int b) { return a + b; }

// 함수 포인터 선언: 반환형과 매개변수 타입이 일치해야 함
int (*fp)(int, int);

// 함수 주소 저장
fp = add;

// 호출
int result = fp(3, 5);  // result = 8
```

선언 문법:

```
반환형 (*포인터이름)(매개변수 타입 목록);
```

배열 포인터(`int (*p)[4]`)와 같은 구조입니다. 괄호가 "포인터임을 먼저" 나타내고, 나머지가 타입을 설명합니다.

---

### 4.2 왜 함수 포인터가 필요한가?

함수 포인터 없이 여러 연산을 처리하면:

```c
if (op == 0)      result = add(a, b);
else if (op == 1) result = subtract(a, b);
else if (op == 2) result = multiply(a, b);
// 연산이 늘어날수록 코드가 계속 길어집니다
```

함수 포인터를 사용하면:

```c
int (*operations[])(int, int) = {add, subtract, multiply};
result = operations[op](a, b);  // 인덱스 하나로 처리
```

---

### 4.3 예제: 계산기

```c
#include <stdio.h>

int add(int a, int b)      { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

int main(void) {
    int (*op[3])(int, int) = {add, subtract, multiply};
    const char *names[3]   = {"add", "subtract", "multiply"};

    int a = 10, b = 4;

    for (int i = 0; i < 3; i++)
        printf("%s(%d, %d) = %d\n", names[i], a, b, op[i](a, b));

    return 0;
}
```

출력:
```
add(10, 4) = 14
subtract(10, 4) = 6
multiply(10, 4) = 40
```

---

### 4.4 콜백(Callback) 패턴

함수 포인터의 핵심 용도는 **콜백**입니다. 함수가 수행할 동작을 외부에서 주입하는 패턴입니다.

```c
#include <stdio.h>

void apply(int *arr, int size, int (*transform)(int)) {
    for (int i = 0; i < size; i++)
        arr[i] = transform(arr[i]);
}

int double_val(int x) { return x * 2; }
int square(int x)     { return x * x; }

int main(void) {
    int data[5] = {1, 2, 3, 4, 5};

    apply(data, 5, double_val);
    for (int i = 0; i < 5; i++) printf("%d ", data[i]);  // 2 4 6 8 10
    printf("\n");

    apply(data, 5, square);
    for (int i = 0; i < 5; i++) printf("%d ", data[i]);  // 4 16 36 64 100
    printf("\n");

    return 0;
}
```

> **전기전자공학 맥락:**
> 임베디드 시스템에서 인터럽트 핸들러(ISR) 등록, 센서 데이터 처리 파이프라인,
> 통신 프로토콜의 이벤트 핸들러 등에 이 패턴이 실제로 사용됩니다.

---

### 4.5 typedef로 가독성 높이기

`typedef`로 함수 포인터 타입에 이름을 붙이면 코드가 훨씬 읽기 쉬워집니다.

```c
// 기존 방식
int (*fp)(int, int);

// typedef 사용
typedef int (*BinaryOp)(int, int);

BinaryOp fp     = add;
BinaryOp ops[3] = {add, subtract, multiply};
```

---

## 정리

| 개념 | 선언 예시 | 핵심 |
|------|-----------|------|
| 2차원 배열 | `int mat[3][4]` | row-major 연속 메모리, 주소 = 시작 + (i×열+j)×sizeof |
| 포인터 배열 | `int *p[4]` | int* 를 4개 담는 배열, `argv` 등에 사용 |
| 배열 포인터 | `int (*p)[4]` | 행 단위 이동, 다차원 배열을 위해 존재 |
| 함수 포인터 | `int (*fp)(int,int)` | 콜백 패턴, 디스패치 테이블 |

**괄호 규칙 (배열 포인터 / 함수 포인터 공통):**
```
괄호 없음 → 배열이나 함수 호출이 먼저 결합
괄호 있음 → 포인터(*)가 먼저 결합
```

**2차원 배열 함수 전달 흐름:**
```
int matrix[3][4]
    → (함수에 넘기면) decay
    → int (*)[4]  (배열 포인터)
    → 함수 선언: void foo(int mat[][4], int rows)
                 void foo(int (*mat)[4], int rows)  // 동일
```

---

## 다음 시간 예고

- 동적 메모리 할당: `malloc`, `calloc`, `realloc`, `free`
- 힙(Heap)과 스택(Stack)의 차이
- 메모리 누수(Memory Leak) 방지

---
