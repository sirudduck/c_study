# Week 2 실습 문제
## 조건문과 반복문 응용

> **사용 가능한 문법**: 변수, 자료형, 연산자, printf, scanf, if-else, switch, for, while
> 
> **사용 불가**: 배열, 함수(main 제외), 포인터

---

## 난이도: ★☆☆ (쉬움)

### 문제 1: 윤년 판별기

**문제**  
연도를 입력받아 윤년인지 판별하는 프로그램을 작성하세요.

**윤년 조건**
1. 4로 나누어떨어지는 해는 윤년
2. 단, 100으로 나누어떨어지는 해는 평년
3. 단, 400으로 나누어떨어지는 해는 윤년

**입력 예시**
```
연도를 입력하세요: 2024
```

**출력 예시**
```
2024년은 윤년입니다.
```

**테스트 케이스**
- 2024 → 윤년 (4로 나누어떨어짐)
- 1900 → 평년 (100으로 나누어떨어지지만 400으로는 안됨)
- 2000 → 윤년 (400으로 나누어떨어짐)
- 2023 → 평년 (4로 나누어떨어지지 않음)

**힌트**
```c
if (year % 400 == 0) {
    // 윤년
} else if (year % 100 == 0) {
    // 평년
} else if (year % 4 == 0) {
    // 윤년
} else {
    // 평년
}
```

---

### 문제 2: 자릿수 합 계산기

**문제**  
양의 정수를 입력받아 각 자릿수의 합을 계산하는 프로그램을 작성하세요.

**예**: 1234 → 1 + 2 + 3 + 4 = 10

**입력 예시**
```
숫자를 입력하세요: 1234
```

**출력 예시**
```
자릿수의 합: 10
```

**힌트**
```c
int num = 1234;
int sum = 0;
int digit;

while (num > 0) {
    digit = num % 10;  // 마지막 자리 추출
    sum += digit;
    num = num / 10;    // 마지막 자리 제거
}
```

**테스트 케이스**
- 1234 → 10
- 999 → 27
- 5 → 5
- 10203 → 6

---

### 문제 3: 구구단 퀴즈

**문제**  
2단부터 9단까지 중 하나를 무작위로 선택하여 구구단 문제 5개를 출력하고, 사용자의 답을 확인하는 프로그램을 작성하세요.

**실행 예시**
```
=== 구구단 퀴즈 ===
단을 선택하세요 (2-9): 3

문제 1: 3 x 1 = ?
답: 3
정답입니다!

문제 2: 3 x 2 = ?
답: 7
틀렸습니다. 정답은 6입니다.

문제 3: 3 x 3 = ?
답: 9
정답입니다!

...

총 5문제 중 3문제를 맞추셨습니다!
정답률: 60%
```

**요구사항**
- 사용자가 선택한 단의 1~9까지 순서대로 출력
- 정답/오답 판정
- 최종 점수 출력

---

## 난이도: ★★☆ (보통)

### 문제 4: 최대공약수(GCD) 계산기

**문제**  
두 양의 정수를 입력받아 최대공약수를 계산하는 프로그램을 작성하세요.

**유클리드 호제법**: GCD(a, b) = GCD(b, a % b), 단 b = 0이면 a가 GCD

**입력 예시**
```
첫 번째 숫자: 48
두 번째 숫자: 18
```

**출력 예시**
```
최대공약수: 6
```

**힌트**
```c
int a = 48, b = 18;
int temp;

while (b != 0) {
    temp = a % b;
    a = b;
    b = temp;
}
// 이제 a가 GCD
```

**테스트 케이스**
- GCD(48, 18) = 6
- GCD(100, 50) = 50
- GCD(17, 19) = 1 (서로소)
- GCD(24, 36) = 12

---

### 문제 5: 숫자 뒤집기

**문제**  
양의 정수를 입력받아 숫자를 거꾸로 뒤집어 출력하는 프로그램을 작성하세요.

**예**: 1234 → 4321

**입력 예시**
```
숫자를 입력하세요: 1234
```

**출력 예시**
```
뒤집은 숫자: 4321
```

**힌트**
```c
int num = 1234;
int reversed = 0;

while (num > 0) {
    reversed = reversed * 10 + (num % 10);
    num = num / 10;
}
```

**실행 과정 (1234 입력)**
```
num = 1234, reversed = 0
→ reversed = 0 * 10 + 4 = 4, num = 123

num = 123, reversed = 4
→ reversed = 4 * 10 + 3 = 43, num = 12

num = 12, reversed = 43
→ reversed = 43 * 10 + 2 = 432, num = 1

num = 1, reversed = 432
→ reversed = 432 * 10 + 1 = 4321, num = 0

종료!
```

**테스트 케이스**
- 1234 → 4321
- 5000 → 5
- 707 → 707
- 98765 → 56789

---

### 문제 6: 완전수 판별기

**문제**  
양의 정수를 입력받아 완전수인지 판별하는 프로그램을 작성하세요.

**완전수**: 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수
- 예: 6 = 1 + 2 + 3
- 예: 28 = 1 + 2 + 4 + 7 + 14

**입력 예시**
```
숫자를 입력하세요: 6
```

**출력 예시**
```
6은 완전수입니다.
약수: 1 + 2 + 3 = 6
```

**입력 예시 2**
```
숫자를 입력하세요: 10
```

**출력 예시 2**
```
10은 완전수가 아닙니다.
약수의 합: 8 (1 + 2 + 5)
```

**힌트**
```c
int num = 6;
int sum = 0;
int i;

// 1부터 num-1까지 약수 찾기
for (i = 1; i < num; i++) {
    if (num % i == 0) {
        sum += i;
    }
}

if (sum == num) {
    // 완전수
}
```

**테스트 케이스**
- 6 → 완전수
- 28 → 완전수
- 496 → 완전수
- 10 → 완전수 아님

---

### 문제 7: 피보나치 수열

**문제**  
N번째 피보나치 수를 구하는 프로그램을 작성하세요.

**피보나치 수열**: F(1) = 1, F(2) = 1, F(n) = F(n-1) + F(n-2)
- 수열: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

**입력 예시**
```
몇 번째 피보나치 수를 구할까요? 7
```

**출력 예시**
```
7번째 피보나치 수: 13
```

**과정 출력 (선택)**
```
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
```

**힌트**
```c
int n = 7;
int fib1 = 1, fib2 = 1;  // F(1), F(2)
int fib_next;
int i;

if (n == 1 || n == 2) {
    // 1 출력
} else {
    for (i = 3; i <= n; i++) {
        fib_next = fib1 + fib2;
        fib1 = fib2;
        fib2 = fib_next;
    }
    // fib_next가 답
}
```

**테스트 케이스**
- F(1) = 1
- F(2) = 1
- F(7) = 13
- F(10) = 55

---

## 난이도: ★★★ (어려움)

### 문제 8: 이차방정식 근 구하기

**문제**  
이차방정식 ax² + bx + c = 0의 계수 a, b, c를 입력받아 근을 구하는 프로그램을 작성하세요.

**근의 공식**: x = (-b ± √(b² - 4ac)) / 2a

**판별식**: D = b² - 4ac
- D > 0: 서로 다른 두 실근
- D = 0: 중근
- D < 0: 허근 (실근 없음)

**입력 예시 1**
```
a를 입력하세요: 1
b를 입력하세요: -5
c를 입력하세요: 6
```

**출력 예시 1**
```
방정식: 1x² + (-5)x + 6 = 0
판별식 D = 1
서로 다른 두 실근:
x1 = 3.00
x2 = 2.00
```

**입력 예시 2**
```
a를 입력하세요: 1
b를 입력하세요: -4
c를 입력하세요: 4
```

**출력 예시 2**
```
방정식: 1x² + (-4)x + 4 = 0
판별식 D = 0
중근: x = 2.00
```

**입력 예시 3**
```
a를 입력하세요: 1
b를 입력하세요: 2
c를 입력하세요: 5
```

**출력 예시 3**
```
방정식: 1x² + 2x + 5 = 0
판별식 D = -16
실근이 존재하지 않습니다.
```

**힌트**
```c
double a, b, c;
double D, x1, x2;

D = b * b - 4 * a * c;

if (D > 0) {
    x1 = (-b + sqrt(D)) / (2 * a);  // sqrt는 #include <math.h> 필요
    x2 = (-b - sqrt(D)) / (2 * a);
} else if (D == 0) {
    x1 = -b / (2 * a);
} else {
    // 실근 없음
}
```

**주의**: `sqrt()` 함수 사용을 위해 `#include <math.h>` 필요
- 컴파일: `clang -o quadratic quadratic.c -lm`

**테스트 케이스**
- (1, -5, 6): x = 3, 2
- (1, -4, 4): x = 2 (중근)
- (1, 2, 5): 실근 없음
- (2, -8, 6): x = 3, 1

---

### 문제 9: 거스름돈 계산기

**문제**  
물건 가격과 지불 금액을 입력받아 거스름돈을 계산하고, 최소 개수의 지폐/동전으로 거슬러주는 프로그램을 작성하세요.

**지폐/동전 종류**: 50000원, 10000원, 5000원, 1000원, 500원, 100원, 50원, 10원

**입력 예시**
```
물건 가격: 37860
지불 금액: 50000
```

**출력 예시**
```
거스름돈: 12140원

50000원: 0장
10000원: 1장
5000원: 0장
1000원: 2장
500원: 0개
100원: 1개
50원: 0개
10원: 4개
```

**요구사항**
- 큰 단위부터 계산
- 개수가 0인 것도 출력

**힌트**
```c
int change = 12140;
int count;

// 만원 계산
count = change / 10000;
printf("10000원: %d장\n", count);
change = change % 10000;  // 남은 금액

// 천원 계산
count = change / 1000;
printf("1000원: %d장\n", count);
change = change % 1000;

// ... 반복
```

**테스트 케이스**
- 거스름돈 12140원: 만원 1장, 천원 2장, 백원 1개, 십원 4개
- 거스름돈 7650원: 오천원 1장, 천원 2장, 오백원 1개, 백원 1개, 오십원 1개
- 거스름돈 999원: 오백원 1개, 백원 4개, 오십원 1개, 십원 4개

---

### 문제 10: 소수 개수 세기

**문제**  
1부터 N까지의 범위에서 소수가 몇 개 있는지 세는 프로그램을 작성하세요.

**소수**: 1과 자기 자신으로만 나누어지는 2 이상의 자연수

**입력 예시**
```
N을 입력하세요: 20
```

**출력 예시**
```
1부터 20까지의 소수:
2 3 5 7 11 13 17 19
총 8개의 소수가 있습니다.
```

**요구사항**
- 모든 소수 출력
- 개수 세기
- 소수 판별 과정 최적화 (√N까지만 검사)

**힌트**
```c
int n = 20;
int count = 0;
int num, i;
int is_prime;  // 1이면 소수, 0이면 합성수

for (num = 2; num <= n; num++) {
    is_prime = 1;  // 일단 소수라고 가정
    
    // 2부터 num-1까지 나누어보기
    for (i = 2; i < num; i++) {
        if (num % i == 0) {
            is_prime = 0;  // 나누어떨어지면 합성수
            break;
        }
    }
    
    if (is_prime) {
        printf("%d ", num);
        count++;
    }
}
```

**최적화 팁**
```c
// 2부터 √num까지만 검사하면 충분
for (i = 2; i * i <= num; i++) {
    if (num % i == 0) {
        is_prime = 0;
        break;
    }
}
```

**테스트 케이스**
- N = 10: 2, 3, 5, 7 (4개)
- N = 20: 2, 3, 5, 7, 11, 13, 17, 19 (8개)
- N = 50: 15개
- N = 100: 25개

---

## 📊 난이도별 요약

### ★☆☆ (쉬움) - 조건문 중심
1. 윤년 판별기
2. 자릿수 합 계산기
3. 구구단 퀴즈

### ★★☆ (보통) - 조건문 + 반복문
4. 최대공약수(GCD) 계산기
5. 숫자 뒤집기
6. 완전수 판별기
7. 피보나치 수열

### ★★★ (어려움) - 알고리즘 사고
8. 이차방정식 근 구하기
9. 거스름돈 계산기
10. 소수 개수 세기

---

## 💡 추가 도전 과제

각 문제를 개선해보세요:

1. **윤년 판별기**: 시작 연도~끝 연도 범위의 모든 윤년 출력
2. **자릿수 합**: 결과가 한 자리가 될 때까지 반복
3. **구구단 퀴즈**: 틀린 문제만 다시 출력
4. **GCD**: GCD를 이용해서 LCM(최소공배수)도 계산
5. **숫자 뒤집기**: 뒤집은 수가 원래 수와 같은지 판별 (회문수)
6. **완전수**: 1~N 범위의 모든 완전수 찾기
7. **피보나치**: N번째까지의 피보나치 수열 전체 출력
8. **이차방정식**: 여러 문제 연속 풀기 (메뉴 추가)
9. **거스름돈**: 최적화 - 동전 개수만 출력 (0인 것 제외)
10. **소수 개수**: 에라토스테네스의 체 알고리즘 연구

---

## 📚 참고 자료

### 수학 개념
- **유클리드 호제법**: 최대공약수 알고리즘
- **완전수**: 6, 28, 496, 8128 (처음 4개)
- **피보나치 수열**: 자연에서 흔히 발견되는 수열
- **근의 공식**: 이차방정식의 해

### C 표준 라이브러리
- `<math.h>`: `sqrt()` - 제곱근 계산
  ```c
  #include <math.h>
  double result = sqrt(16.0);  // 4.0
  ```
- 컴파일 시 `-lm` 옵션 필요: `clang -o prog prog.c -lm`

### 알고리즘 복잡도
- **소수 판별**: O(√n) - i*i <= num까지만 검사
- **GCD**: O(log min(a,b)) - 유클리드 호제법
- **피보나치**: O(n) - 반복문 사용

---

## 🎯 학습 목표 체크리스트

이 문제들을 풀면서 다음을 익힐 수 있습니다:

- [ ] 복잡한 조건문 작성 (윤년, 이차방정식)
- [ ] while 반복문 활용 (자릿수 합, 숫자 뒤집기, GCD)
- [ ] for 반복문 중첩 (소수 판별, 완전수)
- [ ] 변수 교환 기법 (피보나치)
- [ ] 나머지 연산 활용 (자릿수, 거스름돈)
- [ ] 플래그 변수 사용 (소수 판별의 is_prime)
- [ ] 수학 개념을 코드로 구현
- [ ] 효율적인 알고리즘 설계

---

**제출 방법**: Notion 과제 게시판에 코드와 실행 결과 스크린샷 업로드

**추천 순서**: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10

**팁**: 한 번에 다 풀려고 하지 말고, 하루에 2-3문제씩 꾸준히!